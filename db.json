{"meta":{"version":1,"warehouse":"1.0.3"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1},{"_id":"source/uploads/数字签名.jpg","path":"uploads/数字签名.jpg","modified":1},{"_id":"source/uploads/ipa组成.png","path":"uploads/ipa组成.png","modified":1},{"_id":"source/uploads/iOS证书和校验.png","path":"uploads/iOS证书和校验.png","modified":1},{"_id":"source/uploads/http_content_type_4.png","path":"uploads/http_content_type_4.png","modified":1},{"_id":"source/uploads/http_content_type_3.png","path":"uploads/http_content_type_3.png","modified":1},{"_id":"source/uploads/http_content_type_2.png","path":"uploads/http_content_type_2.png","modified":1},{"_id":"source/uploads/http_content_type_1.png","path":"uploads/http_content_type_1.png","modified":1},{"_id":"source/uploads/gitframe.png","path":"uploads/gitframe.png","modified":1},{"_id":"source/uploads/baidudigitalcertificate.png","path":"uploads/baidudigitalcertificate.png","modified":1},{"_id":"source/uploads/avatar.jpg","path":"uploads/avatar.jpg","modified":1},{"_id":"source/uploads/5.png","path":"uploads/5.png","modified":1},{"_id":"source/uploads/4.png","path":"uploads/4.png","modified":1},{"_id":"source/uploads/3.png","path":"uploads/3.png","modified":1},{"_id":"source/uploads/1451875469811263.png","path":"uploads/1451875469811263.png","modified":1},{"_id":"source/uploads/1451875454246244.png","path":"uploads/1451875454246244.png","modified":1},{"_id":"themes/next/source/vendors/velocity/velocity.ui.min.js","path":"vendors/velocity/velocity.ui.min.js","modified":1},{"_id":"themes/next/source/vendors/velocity/velocity.ui.js","path":"vendors/velocity/velocity.ui.js","modified":1},{"_id":"themes/next/source/vendors/velocity/velocity.min.js","path":"vendors/velocity/velocity.min.js","modified":1},{"_id":"themes/next/source/vendors/velocity/velocity.js","path":"vendors/velocity/velocity.js","modified":1},{"_id":"themes/next/source/vendors/velocity/bower.json","path":"vendors/velocity/bower.json","modified":1},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.scrollstop.js","path":"vendors/jquery_lazyload/jquery.scrollstop.js","modified":1},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.lazyload.js","path":"vendors/jquery_lazyload/jquery.lazyload.js","modified":1},{"_id":"themes/next/source/vendors/jquery_lazyload/bower.json","path":"vendors/jquery_lazyload/bower.json","modified":1},{"_id":"themes/next/source/vendors/jquery_lazyload/README.md","path":"vendors/jquery_lazyload/README.md","modified":1},{"_id":"themes/next/source/vendors/jquery_lazyload/CONTRIBUTING.md","path":"vendors/jquery_lazyload/CONTRIBUTING.md","modified":1},{"_id":"themes/next/source/vendors/jquery/index.js","path":"vendors/jquery/index.js","modified":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff2","path":"vendors/font-awesome/fonts/fontawesome-webfont.woff2","modified":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff","path":"vendors/font-awesome/fonts/fontawesome-webfont.woff","modified":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.ttf","path":"vendors/font-awesome/fonts/fontawesome-webfont.ttf","modified":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.svg","path":"vendors/font-awesome/fonts/fontawesome-webfont.svg","modified":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.eot","path":"vendors/font-awesome/fonts/fontawesome-webfont.eot","modified":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/FontAwesome.otf","path":"vendors/font-awesome/fonts/FontAwesome.otf","modified":1},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.min.css","path":"vendors/font-awesome/css/font-awesome.min.css","modified":1},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css.map","path":"vendors/font-awesome/css/font-awesome.css.map","modified":1},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css","path":"vendors/font-awesome/css/font-awesome.css","modified":1},{"_id":"themes/next/source/vendors/font-awesome/bower.json","path":"vendors/font-awesome/bower.json","modified":1},{"_id":"themes/next/source/vendors/font-awesome/HELP-US-OUT.txt","path":"vendors/font-awesome/HELP-US-OUT.txt","modified":1},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.min.js","path":"vendors/fastclick/lib/fastclick.min.js","modified":1},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.js","path":"vendors/fastclick/lib/fastclick.js","modified":1},{"_id":"themes/next/source/vendors/fastclick/bower.json","path":"vendors/fastclick/bower.json","modified":1},{"_id":"themes/next/source/vendors/fastclick/README.md","path":"vendors/fastclick/README.md","modified":1},{"_id":"themes/next/source/vendors/fastclick/LICENSE","path":"vendors/fastclick/LICENSE","modified":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.pack.js","path":"vendors/fancybox/source/jquery.fancybox.pack.js","modified":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.js","path":"vendors/fancybox/source/jquery.fancybox.js","modified":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.css","path":"vendors/fancybox/source/jquery.fancybox.css","modified":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-media.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-media.js","modified":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/fancybox_buttons.png","path":"vendors/fancybox/source/helpers/fancybox_buttons.png","modified":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite@2x.png","path":"vendors/fancybox/source/fancybox_sprite@2x.png","modified":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite.png","path":"vendors/fancybox/source/fancybox_sprite.png","modified":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_overlay.png","path":"vendors/fancybox/source/fancybox_overlay.png","modified":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading@2x.gif","path":"vendors/fancybox/source/fancybox_loading@2x.gif","modified":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading.gif","path":"vendors/fancybox/source/fancybox_loading.gif","modified":1},{"_id":"themes/next/source/vendors/fancybox/source/blank.gif","path":"vendors/fancybox/source/blank.gif","modified":1},{"_id":"themes/next/source/js/ua-parser.min.js","path":"js/ua-parser.min.js","modified":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":1},{"_id":"themes/next/source/js/hook-duoshuo.js","path":"js/hook-duoshuo.js","modified":1},{"_id":"themes/next/source/js/helpers.js","path":"js/helpers.js","modified":1},{"_id":"themes/next/source/js/fancy-box.js","path":"js/fancy-box.js","modified":1},{"_id":"themes/next/source/js/bootstrap.scrollspy.js","path":"js/bootstrap.scrollspy.js","modified":1},{"_id":"themes/next/source/js/bootstrap.js","path":"js/bootstrap.js","modified":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1},{"_id":"source/robots.txt","path":"robots.txt","modified":1},{"_id":"source/favicon.ico","path":"favicon.ico","modified":1}],"Cache":[{"_id":"source/_posts/First-blog.md","shasum":"ffa971d87c51656f2a93990246ffcb5c310c7ef8","modified":1456708742000},{"_id":"source/_posts/UIWindow-cannot-rotate.md","shasum":"92cde22e67965548374e4d45ab661be718e58070","modified":1452132480000},{"_id":"source/CNAME","shasum":"09c89dc7fe1f8a30a8eeb4fadb822b636a9904d3","modified":1450404380000},{"_id":"source/_posts/certification-and-pki.md","shasum":"cfdb9b5c03c9687f7cd521ee3d7dc970e1851b38","modified":1460468014000},{"_id":"source/_posts/development-of-small-notes.md","shasum":"b2a70c823d0d9663cc77a047986893275b3bf8c1","modified":1469169229000},{"_id":"source/_posts/digital-certificate-based.md","shasum":"1fdc7623f634b52cec7db6a2cb14ba5b2f28483d","modified":1458185310000},{"_id":"source/_posts/git-basic-commands.md","shasum":"466838779ca203c86c977815c0e3f550606e1692","modified":1460609470000},{"_id":"source/_posts/ios-associative.md","shasum":"0a3d952935cd6e0b990ce0b5a54aa71b409c1863","modified":1487394184000},{"_id":"source/_posts/http-Content-Type.md","shasum":"39d7663f4c0b0c477ef68314ae8f2080d53d8d92","modified":1472474258000},{"_id":"source/_posts/protobuf-introduce.md","shasum":"5f3e9de9c601faa5d65fa3bf0df281b0dae8c179","modified":1487315071000},{"_id":"source/_posts/ios-certification-and-code-sign-note.md","shasum":"b9f67333ce8a69c8fe7d5481e9753e2cad384d73","modified":1487381784000},{"_id":"source/_posts/ios-xia-opengl-xu-yao-zhu-yi-de-ji-dian.md","shasum":"f1a507e881eaf27883e14ea47a44d3fef3d46160","modified":1452133525000},{"_id":"source/categories/index.md","shasum":"91a185779f67033ddf956835d6710946ff6d454b","modified":1450496420000},{"_id":"source/about/index.md","shasum":"74aeebba8af2f0fd0209e8919f955e454ec05834","modified":1469169531000},{"_id":"source/_posts/sdwebimage-issues.md","shasum":"1dc1942afe29e943d88c53545e14704c7534c846","modified":1452132657000},{"_id":"source/favicon.ico","shasum":"fcd80082b0a7c604ef3a0152962ba12b81db0f66","modified":1450933119000},{"_id":"source/robots.txt","shasum":"f6a203139ca546f7e79aac0ee52a514407fccd96","modified":1451403482000},{"_id":"source/tags/index.md","shasum":"845041c9f7a77f28a2a85ede6b0b07aa1f896a76","modified":1450496463000},{"_id":"source/uploads/1451875469811263.png","shasum":"c0619592d295fc8219724c7f53637c716b5a90c2","modified":1452691062000},{"_id":"source/uploads/1451875454246244.png","shasum":"1adf4c5bf64d27bc7502562a29b01b26165eb787","modified":1452691052000},{"_id":"source/uploads/3.png","shasum":"822f0cd94e0759f9fffc316c5fe8d2e4a1ed653f","modified":1452174164000},{"_id":"source/uploads/4.png","shasum":"0c9fea79b42e0f907c1e0e362bfc6e5c50c98f7a","modified":1452174173000},{"_id":"source/uploads/5.png","shasum":"ae74ce6b6f9505f272d52a9ebbdb4b37b5f41d65","modified":1452823797000},{"_id":"source/uploads/gitframe.png","shasum":"558c5b3217f5613b3d6fbb7b27aaf2e68427fde9","modified":1450668307000},{"_id":"source/uploads/ipa组成.png","shasum":"80e870def1a82264c780de615e2face9a1ecb78c","modified":1452850644000},{"_id":"source/uploads/数字签名.jpg","shasum":"9409fd2e74de3ba395d74680f6a2ecacb1c9c7a1","modified":1453812200000},{"_id":"source/uploads/iOS证书和校验.png","shasum":"e0414782b11e1ed321a569fe4c6227dd3461c2ab","modified":1452850633000},{"_id":"source/uploads/avatar.jpg","shasum":"b0fe2de3526735c077ba4828dbf95247d3de3606","modified":1450414056000},{"_id":"source/uploads/baidudigitalcertificate.png","shasum":"06ee5d4b230fd0ead55690d17ba5b2bf9157d0a8","modified":1460466552000},{"_id":"source/uploads/http_content_type_1.png","shasum":"a2dcbc185712de1e100e2e99f2a3fb78d82104c9","modified":1472472564000},{"_id":"source/uploads/http_content_type_2.png","shasum":"8ac782d3fcf43b9f132e69e356c9818a7b77835f","modified":1472472598000},{"_id":"source/uploads/http_content_type_4.png","shasum":"01a5d2408ac056cb3de469ad91da9a2f279972a5","modified":1472472662000},{"_id":"themes/next/source/css/_common/_page/home.styl","shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1450405270000},{"_id":"themes/next/source/css/_mixins/Mist.styl","shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1450405270000},{"_id":"themes/next/source/css/_mixins/custom.styl","shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1450405270000},{"_id":"themes/next/source/css/_mixins/default.styl","shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1450405270000},{"_id":"themes/next/source/css/_variables/custom.styl","shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1450405270000},{"_id":"themes/next/README.en.md","shasum":"565ba52b3825b85a9f05b41183caca7f18b741d4","modified":1450405270000},{"_id":"themes/next/_config.yml","shasum":"1403506773dfb88dc8279cf38cbe0498081594fb","modified":1491701661000},{"_id":"themes/next/README.md","shasum":"0b709591995001cd860384d6c189e51d91690714","modified":1450405270000},{"_id":"themes/next/languages/de.yml","shasum":"7a8de0e5665c52a1bf168c1e7dd222c8a74fb0ab","modified":1450405270000},{"_id":"themes/next/languages/default.yml","shasum":"f57623e47f533c8d53d859628fa6a368a5298a00","modified":1450405270000},{"_id":"themes/next/bower.json","shasum":"4a53cab758c7d69be2ce773b2afff7dd962b7cb0","modified":1450405270000},{"_id":"themes/next/languages/fr-FR.yml","shasum":"2cec663601ac8d178e97aee91d967fa99a95ad4e","modified":1450405270000},{"_id":"themes/next/languages/en.yml","shasum":"f57623e47f533c8d53d859628fa6a368a5298a00","modified":1450405270000},{"_id":"themes/next/languages/ru.yml","shasum":"1d1b158f9cff1b38978086043f299b3fc590e007","modified":1450405270000},{"_id":"themes/next/languages/pt.yml","shasum":"8e38fdf3a5232b428d2e4a641666dbabab87c3d1","modified":1450405270000},{"_id":"themes/next/languages/zh-Hans.yml","shasum":"c01d18d5c3837bb04d263e845db8f6827fde65de","modified":1450405270000},{"_id":"themes/next/languages/zh-hk.yml","shasum":"248b88c825fde8e35839f3954d38df4e72a0537c","modified":1450405270000},{"_id":"themes/next/languages/zh-tw.yml","shasum":"42ba1d0c6b6026ba1e613ad11efb75432a8132ac","modified":1450405270000},{"_id":"themes/next/layout/_layout.swig","shasum":"4efe52f310b797f4bdedacbd979caf285d2bc731","modified":1450405270000},{"_id":"themes/next/layout/_partials/comments.swig","shasum":"a612a4eca51ffc87b53a5470b451071a7ad6a031","modified":1450405270000},{"_id":"themes/next/layout/_macro/post-collapse.swig","shasum":"9032ae9056cb19b4c2d069d66ead7abf828f9922","modified":1450405270000},{"_id":"themes/next/layout/_macro/post.swig","shasum":"f32eaace2afb0450cf230f96ee8c87f20d6a9072","modified":1450405270000},{"_id":"themes/next/layout/_macro/sidebar.swig","shasum":"88e179ff660874135b17d0febc91d04749053a73","modified":1450405270000},{"_id":"themes/next/layout/_partials/duoshuo-hot-articles.swig","shasum":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1450405270000},{"_id":"themes/next/layout/_partials/footer.swig","shasum":"3cb6e03711d0d2faeea49d01c711545d3af3c3bb","modified":1452511239000},{"_id":"themes/next/layout/_partials/header.swig","shasum":"476333c49a1e7e0402a68a826f67527ac258969d","modified":1450405270000},{"_id":"themes/next/layout/_partials/head.swig","shasum":"fcef099c268bd4964e65cfe3109e3fe99d0b925c","modified":1450405270000},{"_id":"themes/next/layout/_partials/old-browsers.swig","shasum":"dbbfea810bf3a2ed9c83b9a6683037175aacfc67","modified":1450405270000},{"_id":"themes/next/layout/_partials/pagination.swig","shasum":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1450405270000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","shasum":"00c2b49f6289198b0b2b4e157e4ee783277f32a7","modified":1450405270000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","shasum":"eefe2388ff3d424694045eda21346989b123977c","modified":1450405270000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","shasum":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1450405270000},{"_id":"themes/next/layout/_partials/search.swig","shasum":"64f14da26792a17bc27836c4e9d83190175f36e6","modified":1450405270000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","shasum":"63315fcf210799f894208c9f512737096df84962","modified":1450405270000},{"_id":"themes/next/layout/_scripts/analytics/baidu-analytics.swig","shasum":"7c43d66da93cde65b473a7d6db2a86f9a42647d6","modified":1450405270000},{"_id":"themes/next/layout/_scripts/analytics/google-analytics.swig","shasum":"30a23fa7e816496fdec0e932aa42e2d13098a9c2","modified":1450405270000},{"_id":"themes/next/layout/_scripts/analytics.swig","shasum":"33ca06b9bd9a15a19432d5396b85bd319f017319","modified":1450405270000},{"_id":"themes/next/layout/_scripts/analytics/facebook-sdk.swig","shasum":"334176d838ee528e58468d8bc74ff3a6d3f25b2b","modified":1450405270000},{"_id":"themes/next/layout/_scripts/bootstrap.scrollspy.swig","shasum":"85295f126836b95f0837d03e58228bb3cf8c4490","modified":1450405270000},{"_id":"themes/next/layout/_scripts/baidushare.swig","shasum":"d726361945437cf6e48067b3dd041b7e36e98d85","modified":1450405270000},{"_id":"themes/next/layout/_scripts/comments/duoshuo.swig","shasum":"44e3d567fd49c2a093f4a0a8af9f00542c935a58","modified":1450405270000},{"_id":"themes/next/layout/_scripts/comments/disqus.swig","shasum":"3491d3cebabc8a28857200db28a1be65aad6adc2","modified":1450405270000},{"_id":"themes/next/layout/_scripts/helpers.swig","shasum":"4d2cbfca0aaf546a2b5813288073e824c1498fdf","modified":1450405270000},{"_id":"themes/next/layout/_scripts/fancy-box.swig","shasum":"41b4ff1446060c88c33bf666a32277dcf12129f0","modified":1450405270000},{"_id":"themes/next/layout/_scripts/mathjax.swig","shasum":"df03220eb8526e17dc9c9f17780c2d6699367181","modified":1450405270000},{"_id":"themes/next/layout/_scripts/motion.swig","shasum":"0d9761e3b1bb9e666ccc71bad59f035deb5a88c6","modified":1450405270000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","shasum":"7a34b02808f144ee4a11032ae3a149eb634a7e82","modified":1450405270000},{"_id":"themes/next/layout/_scripts/tinysou.swig","shasum":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1450405270000},{"_id":"themes/next/layout/index.swig","shasum":"38b1ad401b748965369296b86327d23082a1fe93","modified":1450405270000},{"_id":"themes/next/layout/category.swig","shasum":"d6b3e1dc5e0b8deade9a084c463126e70188ee9b","modified":1450405270000},{"_id":"themes/next/layout/archive.swig","shasum":"0c3ce594759f347ea90a4ce592a7a18e2ae4cc5c","modified":1450405270000},{"_id":"themes/next/scripts/filters/sticky.js","shasum":"6b1ea0c09105352813357d0fff4e1d3f4c821fa3","modified":1450405270000},{"_id":"themes/next/scripts/merge-configs.js","shasum":"0c56be2e85c694247cfa327ea6d627b99ca265e8","modified":1450405270000},{"_id":"themes/next/scripts/tags/center-quote.js","shasum":"535fc542781021c4326dec24d8495cbb1387634a","modified":1450405270000},{"_id":"themes/next/scripts/tags/full-image.js","shasum":"3acce36db0feb11a982c6c799aa6b6b47df2827c","modified":1450405270000},{"_id":"themes/next/scripts/tags/group-pictures.js","shasum":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1450405270000},{"_id":"themes/next/source/css/_common/_component/back-to-top.styl","shasum":"88cd66910260006aa8e9e795df4948d4b67bfa11","modified":1450405270000},{"_id":"themes/next/layout/tag.swig","shasum":"aab44af54fcbc66fea4ad12b2767ffca3eadd451","modified":1450405270000},{"_id":"themes/next/layout/post.swig","shasum":"a84457e8ced46e63bc7a8a9e0541a6ba53122a92","modified":1450405270000},{"_id":"themes/next/layout/page.swig","shasum":"8019d02232a6dd1a665b6a4d2daef8e5dd2f0049","modified":1450405270000},{"_id":"themes/next/source/css/_common/_component/blockquote-center.styl","shasum":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1450405270000},{"_id":"themes/next/source/css/_common/_component/duoshuo.styl","shasum":"2d2da815ab0981b219ea1973a4aedede48801411","modified":1450405270000},{"_id":"themes/next/source/css/_common/_component/comments.styl","shasum":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1450405270000},{"_id":"themes/next/source/css/_common/_component/buttons.styl","shasum":"81063e0979f04a0f9af37f321d7321dda9abf593","modified":1450405270000},{"_id":"themes/next/source/css/_common/_component/gallery.styl","shasum":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1450405270000},{"_id":"themes/next/source/css/_common/_component/jiathis.styl","shasum":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1450405270000},{"_id":"themes/next/source/css/_common/_component/pagination.styl","shasum":"711c8830886619d4f4a0598b0cde5499dce50c62","modified":1450405270000},{"_id":"themes/next/source/css/_common/_component/group-pictures.styl","shasum":"1ee40743000173495728855f734081eb2b6167cc","modified":1450405270000},{"_id":"themes/next/source/css/_common/_component/posts-collapse.styl","shasum":"6750b61236eb359028da8f2c4765f7c89b03dc9a","modified":1450405270000},{"_id":"themes/next/source/css/_common/_component/posts-type.styl","shasum":"40b593134bf96d1d6095b3439d47820659d7f10b","modified":1450405270000},{"_id":"themes/next/source/css/_common/_component/posts-expand.styl","shasum":"672d5fa7e5b7642d86a4bda176b501508b54860f","modified":1450405270000},{"_id":"themes/next/source/css/_common/_component/posts.styl","shasum":"b05ac51dd266d27f12e39e59a94383fe6474b7b3","modified":1450405270000},{"_id":"themes/next/source/css/_common/_component/tag-cloud.styl","shasum":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1450405270000},{"_id":"themes/next/source/css/_common/_core/base.styl","shasum":"388aa7c69c97728c64941db01e0f29a88837120c","modified":1450405270000},{"_id":"themes/next/source/css/_common/_core/scaffolding.styl","shasum":"1f8acb3331300eec696a09e7859e11f191e16d7f","modified":1450405270000},{"_id":"themes/next/source/css/_common/_core/helpers.styl","shasum":"d339d114e52a9abbc797ec236a8a770c29e288a6","modified":1450405270000},{"_id":"themes/next/source/css/_common/_core/normalize.styl","shasum":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1450405270000},{"_id":"themes/next/source/css/_common/_core/tables.styl","shasum":"5f766cf26f966dbf9dcfe681f40ab9032e3e8a08","modified":1450405270000},{"_id":"themes/next/source/css/_common/_fonts/icon-default.styl","shasum":"8b809aef383bebaeb3f282b47675f3a364ce3569","modified":1450405270000},{"_id":"themes/next/source/css/_common/_fonts/icon-feather.styl","shasum":"80413afacfa656322100ce1900fed1ebcd8f8f44","modified":1450405270000},{"_id":"themes/next/source/css/_common/_fonts/icon-fifty-shades.styl","shasum":"249f75bafa26b99d272352c0646e7497ea680b39","modified":1450405270000},{"_id":"themes/next/source/css/_common/_fonts/icon-font.styl","shasum":"ec3f86739bede393cafcd3e31052c01115ae20d6","modified":1450405270000},{"_id":"themes/next/source/css/_common/_page/archive.styl","shasum":"dff879f55ca65fa79c07e9098719e53eeea7ac88","modified":1450405270000},{"_id":"themes/next/source/css/_common/_fonts/icon-linecons.styl","shasum":"9cdbedb3627ac941cfb063b152abe5a75c3c699a","modified":1450405270000},{"_id":"themes/next/source/css/_common/_page/categories.styl","shasum":"4f696a2eaeee2f214adcf273eab25c62a398077a","modified":1450405270000},{"_id":"themes/next/source/css/_common/_page/post-detail.styl","shasum":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1450405270000},{"_id":"themes/next/source/css/_common/_section/body.styl","shasum":"ca1a4766cbe25baac757c6b47a4858d221afdc40","modified":1450405270000},{"_id":"themes/next/source/css/_common/_section/footer.styl","shasum":"8994ffcce84deac0471532f270f97c44fea54dc0","modified":1450405270000},{"_id":"themes/next/source/css/_common/_section/media.styl","shasum":"fa9809d2ecc753cf32f70803c1d0821c405211f4","modified":1450405270000},{"_id":"themes/next/source/css/_common/_section/layout.styl","shasum":"03ae7b808dde9065412968aa69916162e790455d","modified":1450405270000},{"_id":"themes/next/source/css/_common/_section/header.styl","shasum":"a6aa8a56f9f645ae5a76a1034f79adf73b053aa0","modified":1450405270000},{"_id":"themes/next/source/css/_common/_vendor/highlight/theme.styl","shasum":"ae19721ceee5ba460e131cb2427dae3c1ff39d6f","modified":1450405270000},{"_id":"themes/next/source/css/_common/_vendor/highlight/highlight.styl","shasum":"6242be4307a3b3dafc14e556f51c8875c41a1ddd","modified":1450405270000},{"_id":"themes/next/source/css/_custom/custom.styl","shasum":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1450405270000},{"_id":"themes/next/source/css/_common/_section/sidebar.styl","shasum":"bc106c3e759cd752c2b4c53ac27bc5ef5e3b18ea","modified":1450405270000},{"_id":"themes/next/source/css/_mixins/base.styl","shasum":"4e49707c99c8bbcfa0a607dfdaff0fbb7dffd2a3","modified":1450405270000},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","shasum":"d50c2a9ae363d26ed2e9bc226a9dc7abeb9ace1b","modified":1450405270000},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","shasum":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1450405270000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","shasum":"1631a430655eadb485574d1a9bedd49460988b11","modified":1450405270000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","shasum":"5a8036fc61207ca0fe38c9782ed2f686fbf764be","modified":1450405270000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","shasum":"4303776991ef28f5742ca51c7dffe6f12f0acf34","modified":1450405270000},{"_id":"themes/next/source/css/_schemes/default/_logo.styl","shasum":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1450405270000},{"_id":"themes/next/source/css/_schemes/default/_menu.styl","shasum":"4bba29cece65ffc5122f4e052063dea4439fe4ae","modified":1450405270000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","shasum":"fc7d96b897290dbd93bc8c515a2058fc4c374ea7","modified":1450405270000},{"_id":"themes/next/source/css/_schemes/default/_search.styl","shasum":"c524bccdc554349106d1c8be9c3f275d4c0d4281","modified":1450405270000},{"_id":"themes/next/source/css/_variables/Mist.styl","shasum":"9f8791860cc1ca724d2dfe609e8cd6abc44d6926","modified":1450405270000},{"_id":"themes/next/source/css/_schemes/default/index.styl","shasum":"159464cb8a7e01e32db9ec70dec391ec70a72f9c","modified":1450405270000},{"_id":"themes/next/source/css/_variables/base.styl","shasum":"f532d6b0f961a8f3867c06e132233286f110180d","modified":1450405270000},{"_id":"themes/next/source/css/_variables/default.styl","shasum":"8ec3307fe42d738b1bbda4b6419d0995f5560222","modified":1450405270000},{"_id":"themes/next/source/css/main.styl","shasum":"56dacee56c5eaa4b2676d196452314fb50f758aa","modified":1450405270000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","shasum":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1450405270000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","shasum":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1450405270000},{"_id":"themes/next/source/images/cc-by-nc.svg","shasum":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1450405270000},{"_id":"themes/next/source/images/cc-by-sa.svg","shasum":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1450405270000},{"_id":"themes/next/source/images/cc-by-nd.svg","shasum":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1450405270000},{"_id":"themes/next/source/images/cc-by.svg","shasum":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1450405270000},{"_id":"themes/next/source/images/cc-zero.svg","shasum":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1450405270000},{"_id":"themes/next/source/images/loading.gif","shasum":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1450405270000},{"_id":"themes/next/source/images/quote-l.svg","shasum":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1450405270000},{"_id":"themes/next/source/images/quote-r.svg","shasum":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1450405270000},{"_id":"themes/next/source/images/placeholder.gif","shasum":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1450405270000},{"_id":"themes/next/source/images/searchicon.png","shasum":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1450405270000},{"_id":"themes/next/source/js/bootstrap.js","shasum":"f9b637b6d064f728d7dc2b6b5058a006a4454299","modified":1450405270000},{"_id":"themes/next/source/js/bootstrap.scrollspy.js","shasum":"ae7bdce88b515aade4eea8bf7407eec458bcd625","modified":1450405270000},{"_id":"themes/next/source/js/fancy-box.js","shasum":"b5fa638ed371b5f658b0826ec4afee25d9986ef2","modified":1450405270000},{"_id":"themes/next/source/js/helpers.js","shasum":"c15216ef897334362789ba37464298948b2eef95","modified":1450405270000},{"_id":"themes/next/source/js/hook-duoshuo.js","shasum":"ccb32e0a1acf798337c9697e1aab5484b52f9df4","modified":1450405270000},{"_id":"themes/next/source/js/motion.js","shasum":"b4132517fe499538ad725094593fb7ead8c04bf7","modified":1450405270000},{"_id":"themes/next/source/js/ua-parser.min.js","shasum":"1148fa2bcb8b2e40c31e5f597bf794a57369a2e6","modified":1450405270000},{"_id":"themes/next/source/vendors/fancybox/source/blank.gif","shasum":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1450405270000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading.gif","shasum":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1450405270000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite.png","shasum":"17df19f97628e77be09c352bf27425faea248251","modified":1450405270000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading@2x.gif","shasum":"273b123496a42ba45c3416adb027cd99745058b0","modified":1450405270000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_overlay.png","shasum":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1450405270000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite@2x.png","shasum":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1450405270000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","shasum":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1450405270000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","shasum":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1450405270000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/fancybox_buttons.png","shasum":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1450405270000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-media.js","shasum":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1450405270000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","shasum":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1450405270000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","shasum":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1450405270000},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.css","shasum":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1450405270000},{"_id":"themes/next/source/vendors/fastclick/README.md","shasum":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1450405270000},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.pack.js","shasum":"53360764b429c212f424399384417ccc233bb3be","modified":1450405270000},{"_id":"themes/next/source/vendors/fastclick/LICENSE","shasum":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1450405270000},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.js","shasum":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1450405270000},{"_id":"themes/next/source/vendors/fastclick/bower.json","shasum":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1450405270000},{"_id":"themes/next/source/vendors/font-awesome/bower.json","shasum":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1450405270000},{"_id":"themes/next/source/vendors/font-awesome/HELP-US-OUT.txt","shasum":"69a4c537d167b68a0ccf1c6febd138aeffca60d6","modified":1450405270000},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.min.js","shasum":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1450405270000},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.js","shasum":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1450405270000},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css.map","shasum":"0189d278706509412bac4745f96c83984e1d59f4","modified":1450405270000},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css","shasum":"3b87c2560832748cd06f9bfd2fd6ea8edbdae8c7","modified":1450405270000},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.min.css","shasum":"05ea25bc9b3ac48993e1fee322d3bc94b49a6e22","modified":1450405270000},{"_id":"themes/next/source/vendors/jquery_lazyload/CONTRIBUTING.md","shasum":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1450405270000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff2","shasum":"574ea2698c03ae9477db2ea3baf460ee32f1a7ea","modified":1450405270000},{"_id":"themes/next/source/vendors/jquery_lazyload/README.md","shasum":"895d50fa29759af7835256522e9dd7dac597765c","modified":1450405270000},{"_id":"themes/next/source/vendors/jquery_lazyload/bower.json","shasum":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1450405270000},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.lazyload.js","shasum":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1450405270000},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.scrollstop.js","shasum":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1450405270000},{"_id":"themes/next/source/vendors/velocity/bower.json","shasum":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1450405270000},{"_id":"themes/next/source/vendors/velocity/velocity.min.js","shasum":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1450405270000},{"_id":"themes/next/source/vendors/velocity/velocity.ui.js","shasum":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1450405270000},{"_id":"themes/next/test/intern.js","shasum":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1450405270000},{"_id":"themes/next/test/helpers.js","shasum":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1450405270000},{"_id":"themes/next/source/vendors/velocity/velocity.ui.min.js","shasum":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1450405270000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.eot","shasum":"b3c2f08e73320135b69c23a3908b87a12053a2f6","modified":1450405270000},{"_id":"themes/next/source/vendors/font-awesome/fonts/FontAwesome.otf","shasum":"0112e96f327d413938d37c1693806f468ffdbace","modified":1450405270000},{"_id":"themes/next/source/vendors/jquery/index.js","shasum":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1450405270000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff","shasum":"507970402e328b2baeb05bde73bf9ded4e2c3a2d","modified":1450405270000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.ttf","shasum":"27cf1f2ec59aece6938c7bb2feb0e287ea778ff9","modified":1450405270000},{"_id":"source/uploads/http_content_type_3.png","shasum":"e72fe73280013a17100153b61fd354b0de852590","modified":1472472703000},{"_id":"themes/next/source/vendors/velocity/velocity.js","shasum":"e63dc7cea055ca60a95d286f32349d88b10c5a4d","modified":1450405270000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.svg","shasum":"2b3c8ba7008cc014d8fb37abc6f9f49aeda83824","modified":1450405270000}],"Category":[{"name":"开发笔记","_id":"cj1a0t0830004gdp1hsf07goi"},{"name":"知识整理/总结","_id":"cj1a0t08a000dgdp1h7qsfl22"},{"name":"default","_id":"cj1a0t09b0024gdp1bxkk3tqd"}],"Data":[],"Page":[{"title":"tags","date":"2015-12-18T04:52:01.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"title: tags\ndate: 2015-12-18 12:52:01\ntype: \"tags\"\ncomments: false\n---\n","updated":"2015-12-19T03:41:03.000Z","path":"tags/index.html","layout":"page","_id":"cj1a0t07q0000gdp1k2j1ze7s"},{"title":"categories","date":"2015-12-19T03:38:59.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"title: categories\ndate: 2015-12-19 11:38:59\ntype: \"categories\"\ncomments: false\n---\n","updated":"2015-12-19T03:40:20.000Z","path":"categories/index.html","layout":"page","_id":"cj1a0t07u0001gdp1m1udjehw"},{"title":"about","date":"2015-12-18T04:50:16.000Z","comments":0,"_content":"\n## 关于 Enki\n\n嗨，我是 Enki，一名来自广州的 iOS 开发者。目前就职于 CVTE，一名崇尚自由的白羊座 Boy。  \n工作之余喜欢听音乐、旅行、摄影、吉他、户外徒步、篮球以及游戏。\n\n> 自由自在地思想，自由自在地瞎想，  \n> 自由自在地少想，自由自在地选择我自己的生活，选择我自身。  \n> 　　　　　　　　　　　　　　　　　　　by 弗朗索瓦丝·萨冈\n\n## 我的联系方式\n`email:` xc120313778#163.com  \n`github:` https://github.com/EnkiChen","source":"about/index.md","raw":"title: about\ndate: 2015-12-18 12:50:16\ncomments: false\n---\n\n## 关于 Enki\n\n嗨，我是 Enki，一名来自广州的 iOS 开发者。目前就职于 CVTE，一名崇尚自由的白羊座 Boy。  \n工作之余喜欢听音乐、旅行、摄影、吉他、户外徒步、篮球以及游戏。\n\n> 自由自在地思想，自由自在地瞎想，  \n> 自由自在地少想，自由自在地选择我自己的生活，选择我自身。  \n> 　　　　　　　　　　　　　　　　　　　by 弗朗索瓦丝·萨冈\n\n## 我的联系方式\n`email:` xc120313778#163.com  \n`github:` https://github.com/EnkiChen","updated":"2016-07-22T06:38:51.000Z","path":"about/index.html","layout":"page","_id":"cj1a0t07w0002gdp11nubjzid"}],"Post":[{"title":"优化APP时发现的SDWebImage的问题","date":"2015-12-22T11:34:17.000Z","_content":"### 起因 旋转了的图片\n前段时间在对程序的绘图逻辑进行了使用OpenGL做优化，但是在使用OpenGL进行绘制时发现一些图片会莫名其妙的旋转，在细看了代码之后发现问题发生在**UIImage**对象的**imageOrientation**属性。该属性为枚举类型可以有以下取值：  \n<!--more-->\n\n```\ntypedef enum {\n    UIImageOrientationUp,            // default orientation  默认方向   \n    UIImageOrientationDown,          // 180 deg rotation     旋转180度    \n    UIImageOrientationLeft,          // 90 deg CCW           逆时针旋转90度\n    UIImageOrientationRight,         // 90 deg CW            顺时针旋转90度\n    UIImageOrientationUpMirrored,    // horizontal flip      向上水平翻转\n    UIImageOrientationDownMirrored,  // horizontal flip      向下水平翻转\n    UIImageOrientationLeftMirrored,  // vertical flip        逆时针旋转90度，垂直翻转\n    UIImageOrientationRightMirrored, // vertical flip        顺时针旋转90度，垂直翻转\n} UIImageOrientation;\n```\n\n该属性用来记录照片的方向信息，在使用iPhone或者iPad自带的照相机拍摄出来的照片含有EXIF信息，而在使用Core Graphics进行绘制时，会进行一些转换，我在使用OpenGL绘制时直接使用的原图，转换成纹理对象时是旋转的图片对象，所以在使用OpenGL绘制会出现旋转问题。在网上找了一下代码做了调整：\n\n```\n- (UIImage *)fixOrientation{\n    \n    // No-op if the orientation is already correct\n    if (self.imageOrientation == UIImageOrientationUp)\n        return self;\n    \n    // We need to calculate the proper transformation to make the image upright.\n    // We do it in 2 steps: Rotate if Left/Right/Down, and then flip if Mirrored.\n    CGAffineTransform transform = CGAffineTransformIdentity;\n    \n    switch (self.imageOrientation) {\n        case UIImageOrientationDown:\n        case UIImageOrientationDownMirrored:\n            transform = CGAffineTransformTranslate(transform, self.size.width, self.size.height);\n            transform = CGAffineTransformRotate(transform, M_PI);\n            break;\n            \n        case UIImageOrientationLeft:\n        case UIImageOrientationLeftMirrored:\n            transform = CGAffineTransformTranslate(transform, self.size.width, 0);\n            transform = CGAffineTransformRotate(transform, M_PI_2);\n            break;\n            \n        case UIImageOrientationRight:\n        case UIImageOrientationRightMirrored:\n            transform = CGAffineTransformTranslate(transform, 0, self.size.height);\n            transform = CGAffineTransformRotate(transform, -M_PI_2);\n            break;\n        default:\n            break;\n    }\n    \n    switch (self.imageOrientation) {\n        case UIImageOrientationUpMirrored:\n        case UIImageOrientationDownMirrored:\n            transform = CGAffineTransformTranslate(transform, self.size.width, 0);\n            transform = CGAffineTransformScale(transform, -1, 1);\n            break;\n            \n        case UIImageOrientationLeftMirrored:\n        case UIImageOrientationRightMirrored:\n            transform = CGAffineTransformTranslate(transform, self.size.height, 0);\n            transform = CGAffineTransformScale(transform, -1, 1);\n            break;\n        default:\n            break;\n    }\n    \n    // Now we draw the underlying CGImage into a new context, applying the transform\n    // calculated above.\n    CGContextRef ctx = CGBitmapContextCreate(NULL, self.size.width, self.size.height,\n                                             CGImageGetBitsPerComponent(self.CGImage), 0,\n                                             CGImageGetColorSpace(self.CGImage),\n                                             CGImageGetBitmapInfo(self.CGImage));\n    CGContextConcatCTM(ctx, transform);\n    switch (self.imageOrientation) {\n        case UIImageOrientationLeft:\n        case UIImageOrientationLeftMirrored:\n        case UIImageOrientationRight:\n        case UIImageOrientationRightMirrored:\n            // Grr...\n            CGContextDrawImage(ctx, CGRectMake(0,0,self.size.height,self.size.width), self.CGImage);\n            break;\n            \n        default:\n            CGContextDrawImage(ctx, CGRectMake(0,0,self.size.width,self.size.height), self.CGImage);\n            break;\n    }\n    \n    // And now we just create a new UIImage from the drawing context\n    CGImageRef cgimg = CGBitmapContextCreateImage(ctx);\n    UIImage *img = [UIImage imageWithCGImage:cgimg];\n    CGContextRelease(ctx);\n    CGImageRelease(cgimg);\n    return img;\n}\n```\n### 再次遇到旋转问题\n\n旋转问题得到解决之后，使用了**SDWebImage**自带的**SDImageCache**类进行了图片的缓存管理，该类能够做到内存不足时释放不需要的图片对象。类底层使用了系统的**NSCache**实现的，能够在系统内存不足时释放被管理的对象。   \n\n在使用**SDImageCache**类做缓存之后，我们的测试MM发现在一些情况下会出现图片旋转的问题。而且是 Core Graphics 和 OpenGL 两个环境下都会出现。因为有了前面的经验，很快就找到了方向，那就是**UIImage**对象的**imageOrientation**属性出问题了，经过一步步调试发现，在**UIImage**对象交给**SDImageCache**管理之后，再从缓存中拿出来时**imageOrientation**属性会不一致。于是找到了**SDImageCache**类的部分源码，如下：\n\n```\n- (void)storeImage:(UIImage *)image recalculateFromImage:(BOOL)recalculate imageData:(NSData *)imageData forKey:(NSString *)key toDisk:(BOOL)toDisk {\n    if (!image || !key) {\n        return;\n    }\n\n    [self.memCache setObject:image forKey:key cost:image.size.height * image.size.width * image.scale * image.scale];\n\n    if (toDisk) {\n        dispatch_async(self.ioQueue, ^{\n            NSData *data = imageData;\n\n            if (image && (recalculate || !data)) {\n#if TARGET_OS_IPHONE\n                // We need to determine if the image is a PNG or a JPEG\n                // PNGs are easier to detect because they have a unique signature (http://www.w3.org/TR/PNG-Structure.html)\n                // The first eight bytes of a PNG file always contain the following (decimal) values:\n                // 137 80 78 71 13 10 26 10\n\n                // We assume the image is PNG, in case the imageData is nil (i.e. if trying to save a UIImage directly),\n                // we will consider it PNG to avoid loosing the transparency\n                BOOL imageIsPng = YES;\n\n                // But if we have an image data, we will look at the preffix\n                if ([imageData length] >= [kPNGSignatureData length]) {\n                    imageIsPng = ImageDataHasPNGPreffix(imageData);\n                }\n\n                if (imageIsPng) {\n                    data = UIImagePNGRepresentation(image);\n                }\n                else {\n                    data = UIImageJPEGRepresentation(image, (CGFloat)1.0);\n                }\n#else\n                data = [NSBitmapImageRep representationOfImageRepsInArray:image.representations usingType: NSJPEGFileType properties:nil];\n#endif\n            }\n\n            if (data) {\n                if (![_fileManager fileExistsAtPath:_diskCachePath]) {\n                    [_fileManager createDirectoryAtPath:_diskCachePath withIntermediateDirectories:YES attributes:nil error:NULL];\n                }\n\n                [_fileManager createFileAtPath:[self defaultCachePathForKey:key] contents:data attributes:nil];\n            }\n        });\n    }\n}\n\n```\n可以知道**UIImage**对象在IO线程中直接使用**UIImagePNGRepresentation**或者**UIImageJPEGRepresentation**方法转换成**NSData**对象然后直接存储到文件中了。 **imageData**参数可以从以下两个方法知道，默认情况下是传的**nil**值。\n\n```\n- (void)storeImage:(UIImage *)image forKey:(NSString *)key {\n    [self storeImage:image recalculateFromImage:YES imageData:nil forKey:key toDisk:YES];\n}\n\n- (void)storeImage:(UIImage *)image forKey:(NSString *)key toDisk:(BOOL)toDisk {\n    [self storeImage:image recalculateFromImage:YES imageData:nil forKey:key toDisk:toDisk];\n}\n```\n \n也就是说我们在使用**SDImageCache**做缓存时，默认会当做PNG图片存储到文件。而经过测试发现**UIImagePNGRepresentation**方法转换成**NSData**对象时，EXIF信息将会丢失，而**UIImageJPEGRepresentation**方法则不会。在找到原因之后，问题就可以很好的解决了，只要在加入到缓存之前，将图片恢复到正常方向，再将图片保存到缓存中即可。  \n\n### 获取缓存失败\n本以为问题都解决了，然而第二天我们测试发现在一些情况下，插入图片时会显示一张默认图片（图片如果加载失败会显示一张默认的小图），在跟测试MM做了一些沟通之后，走读了一下代码流程，并进行了调试，发现图片被放进缓存之后，再次进行获取时，却获取不到数据。  \n\n想不通为什么，于是看了一下**SDImageCache**类的源码（前面有提到），结合调试发现的一些信息，在加载iPad（我们的应用是iPad）拍摄的照片并且在插入多张图片之后才会出现这种现象，于是猜想是不是在**UIImage**对象在加入到缓存中之后，这时候收到内存警告或者超过设定的阀值，导致被加入的对象在IO线程还未将图片写入到磁盘之前就被释放了，这样将导致从内存和磁盘中都获取不到数据。为了验证这个猜想，修改了**SDImageCache**源码，设置了memCache的delegate，**NSCache**有个delegate，协议如下：\n\n```\n@protocol NSCacheDelegate <NSObject>\n@optional\n- (void)cache:(NSCache *)cache willEvictObject:(id)obj;\n@end\n```\n\n通过该protocol便可以知道被加入缓存中的对象什么时候被释放。在delegate中、IO线程中写入文件成功之后以及获取**UIImage**对象时添加一些Log信息。这样便可以知道各个逻辑的执行流程。经过验证，执行流程我猜想的一样，**UIImage**对象在加入到缓存一小会时间之后立马被释放了，这时候IO线程还未执行完成，这时候从缓存中是获取不到缓存数据的。从而导致失败显示默认图片。  \n\n问题已经找到了，但是要解决这个问题很是蛋疼，分别有以下几种做法：\n* 修改上层逻辑代码等待IO线程写入成功后，才执行后续流程，这样确保一定能获取到数据。\n* 修改**SDWebImage**让内存数据不那么快被释放。\n* 自己重新造个轮子达到我们想要的要求。\n\n对于上述修改第一条有点恶心，有点打补丁的节奏。针对后两条不太实际，工作量太大，最近在[**ibireme**](http://blog.ibireme.com/)的博客上看一个[**YYCache**](https://github.com/ibireme/YYCache)的开源项目，看了介绍还不错，于是将项目中的缓存直接换成了**YYCache**，做了相同的测试，发现问题没有出现了。^o^，后续将阅读一下**YYCache**的源代码了，看看具体的实现方法。\n\n### 总结\n在优化的过程中发现了**SDWebImage**的两个问题分别为：\n* 在使用**SDWebImage**做图片缓存时，图片默认会被当做PNG格式存储，而**UIImagePNGRepresentation**方法转换成**NSData**时会丢失EXIF信息，这样当再次从磁盘读取数据时，将是丢失EXIF信息的图片，从而导致无法进行正常的图片旋转。\n* 使用**SDWebImage**做缓存时，当内存到达一个临界值时，加入的新的缓存对象，会在IO线程写入文件之前释放，在内存对象被释放，IO未完成写入的这段时间内，无法正确获取到缓存数据。  \n\n[**SDWebImage**](https://github.com/rs/SDWebImage)很多人在用，而且使用起来也很方便，尤其在加载网络图片时非常方便，项目中还将继续使用用来做网络图片的加载，不过内存缓存会使用[**YYCache**](https://github.com/ibireme/YYCache)， 针对[**YYCache**](https://github.com/ibireme/YYCache)这个类，还没来得及细看代码，网上评价作者代码相当工整，看过[**YYCategories**](https://github.com/ibireme/YYCategories)部分源码实现，确实写的不错，今后多看看，向大牛们学习。\n\n\n\n\n\n\n\n\n\n","source":"_posts/sdwebimage-issues.md","raw":"title: 优化APP时发现的SDWebImage的问题\ndate: 2015-12-22 19:34:17\ncategories: 开发笔记 \ntags: [SDWebImage, NSCache, 旋转]\n---\n### 起因 旋转了的图片\n前段时间在对程序的绘图逻辑进行了使用OpenGL做优化，但是在使用OpenGL进行绘制时发现一些图片会莫名其妙的旋转，在细看了代码之后发现问题发生在**UIImage**对象的**imageOrientation**属性。该属性为枚举类型可以有以下取值：  \n<!--more-->\n\n```\ntypedef enum {\n    UIImageOrientationUp,            // default orientation  默认方向   \n    UIImageOrientationDown,          // 180 deg rotation     旋转180度    \n    UIImageOrientationLeft,          // 90 deg CCW           逆时针旋转90度\n    UIImageOrientationRight,         // 90 deg CW            顺时针旋转90度\n    UIImageOrientationUpMirrored,    // horizontal flip      向上水平翻转\n    UIImageOrientationDownMirrored,  // horizontal flip      向下水平翻转\n    UIImageOrientationLeftMirrored,  // vertical flip        逆时针旋转90度，垂直翻转\n    UIImageOrientationRightMirrored, // vertical flip        顺时针旋转90度，垂直翻转\n} UIImageOrientation;\n```\n\n该属性用来记录照片的方向信息，在使用iPhone或者iPad自带的照相机拍摄出来的照片含有EXIF信息，而在使用Core Graphics进行绘制时，会进行一些转换，我在使用OpenGL绘制时直接使用的原图，转换成纹理对象时是旋转的图片对象，所以在使用OpenGL绘制会出现旋转问题。在网上找了一下代码做了调整：\n\n```\n- (UIImage *)fixOrientation{\n    \n    // No-op if the orientation is already correct\n    if (self.imageOrientation == UIImageOrientationUp)\n        return self;\n    \n    // We need to calculate the proper transformation to make the image upright.\n    // We do it in 2 steps: Rotate if Left/Right/Down, and then flip if Mirrored.\n    CGAffineTransform transform = CGAffineTransformIdentity;\n    \n    switch (self.imageOrientation) {\n        case UIImageOrientationDown:\n        case UIImageOrientationDownMirrored:\n            transform = CGAffineTransformTranslate(transform, self.size.width, self.size.height);\n            transform = CGAffineTransformRotate(transform, M_PI);\n            break;\n            \n        case UIImageOrientationLeft:\n        case UIImageOrientationLeftMirrored:\n            transform = CGAffineTransformTranslate(transform, self.size.width, 0);\n            transform = CGAffineTransformRotate(transform, M_PI_2);\n            break;\n            \n        case UIImageOrientationRight:\n        case UIImageOrientationRightMirrored:\n            transform = CGAffineTransformTranslate(transform, 0, self.size.height);\n            transform = CGAffineTransformRotate(transform, -M_PI_2);\n            break;\n        default:\n            break;\n    }\n    \n    switch (self.imageOrientation) {\n        case UIImageOrientationUpMirrored:\n        case UIImageOrientationDownMirrored:\n            transform = CGAffineTransformTranslate(transform, self.size.width, 0);\n            transform = CGAffineTransformScale(transform, -1, 1);\n            break;\n            \n        case UIImageOrientationLeftMirrored:\n        case UIImageOrientationRightMirrored:\n            transform = CGAffineTransformTranslate(transform, self.size.height, 0);\n            transform = CGAffineTransformScale(transform, -1, 1);\n            break;\n        default:\n            break;\n    }\n    \n    // Now we draw the underlying CGImage into a new context, applying the transform\n    // calculated above.\n    CGContextRef ctx = CGBitmapContextCreate(NULL, self.size.width, self.size.height,\n                                             CGImageGetBitsPerComponent(self.CGImage), 0,\n                                             CGImageGetColorSpace(self.CGImage),\n                                             CGImageGetBitmapInfo(self.CGImage));\n    CGContextConcatCTM(ctx, transform);\n    switch (self.imageOrientation) {\n        case UIImageOrientationLeft:\n        case UIImageOrientationLeftMirrored:\n        case UIImageOrientationRight:\n        case UIImageOrientationRightMirrored:\n            // Grr...\n            CGContextDrawImage(ctx, CGRectMake(0,0,self.size.height,self.size.width), self.CGImage);\n            break;\n            \n        default:\n            CGContextDrawImage(ctx, CGRectMake(0,0,self.size.width,self.size.height), self.CGImage);\n            break;\n    }\n    \n    // And now we just create a new UIImage from the drawing context\n    CGImageRef cgimg = CGBitmapContextCreateImage(ctx);\n    UIImage *img = [UIImage imageWithCGImage:cgimg];\n    CGContextRelease(ctx);\n    CGImageRelease(cgimg);\n    return img;\n}\n```\n### 再次遇到旋转问题\n\n旋转问题得到解决之后，使用了**SDWebImage**自带的**SDImageCache**类进行了图片的缓存管理，该类能够做到内存不足时释放不需要的图片对象。类底层使用了系统的**NSCache**实现的，能够在系统内存不足时释放被管理的对象。   \n\n在使用**SDImageCache**类做缓存之后，我们的测试MM发现在一些情况下会出现图片旋转的问题。而且是 Core Graphics 和 OpenGL 两个环境下都会出现。因为有了前面的经验，很快就找到了方向，那就是**UIImage**对象的**imageOrientation**属性出问题了，经过一步步调试发现，在**UIImage**对象交给**SDImageCache**管理之后，再从缓存中拿出来时**imageOrientation**属性会不一致。于是找到了**SDImageCache**类的部分源码，如下：\n\n```\n- (void)storeImage:(UIImage *)image recalculateFromImage:(BOOL)recalculate imageData:(NSData *)imageData forKey:(NSString *)key toDisk:(BOOL)toDisk {\n    if (!image || !key) {\n        return;\n    }\n\n    [self.memCache setObject:image forKey:key cost:image.size.height * image.size.width * image.scale * image.scale];\n\n    if (toDisk) {\n        dispatch_async(self.ioQueue, ^{\n            NSData *data = imageData;\n\n            if (image && (recalculate || !data)) {\n#if TARGET_OS_IPHONE\n                // We need to determine if the image is a PNG or a JPEG\n                // PNGs are easier to detect because they have a unique signature (http://www.w3.org/TR/PNG-Structure.html)\n                // The first eight bytes of a PNG file always contain the following (decimal) values:\n                // 137 80 78 71 13 10 26 10\n\n                // We assume the image is PNG, in case the imageData is nil (i.e. if trying to save a UIImage directly),\n                // we will consider it PNG to avoid loosing the transparency\n                BOOL imageIsPng = YES;\n\n                // But if we have an image data, we will look at the preffix\n                if ([imageData length] >= [kPNGSignatureData length]) {\n                    imageIsPng = ImageDataHasPNGPreffix(imageData);\n                }\n\n                if (imageIsPng) {\n                    data = UIImagePNGRepresentation(image);\n                }\n                else {\n                    data = UIImageJPEGRepresentation(image, (CGFloat)1.0);\n                }\n#else\n                data = [NSBitmapImageRep representationOfImageRepsInArray:image.representations usingType: NSJPEGFileType properties:nil];\n#endif\n            }\n\n            if (data) {\n                if (![_fileManager fileExistsAtPath:_diskCachePath]) {\n                    [_fileManager createDirectoryAtPath:_diskCachePath withIntermediateDirectories:YES attributes:nil error:NULL];\n                }\n\n                [_fileManager createFileAtPath:[self defaultCachePathForKey:key] contents:data attributes:nil];\n            }\n        });\n    }\n}\n\n```\n可以知道**UIImage**对象在IO线程中直接使用**UIImagePNGRepresentation**或者**UIImageJPEGRepresentation**方法转换成**NSData**对象然后直接存储到文件中了。 **imageData**参数可以从以下两个方法知道，默认情况下是传的**nil**值。\n\n```\n- (void)storeImage:(UIImage *)image forKey:(NSString *)key {\n    [self storeImage:image recalculateFromImage:YES imageData:nil forKey:key toDisk:YES];\n}\n\n- (void)storeImage:(UIImage *)image forKey:(NSString *)key toDisk:(BOOL)toDisk {\n    [self storeImage:image recalculateFromImage:YES imageData:nil forKey:key toDisk:toDisk];\n}\n```\n \n也就是说我们在使用**SDImageCache**做缓存时，默认会当做PNG图片存储到文件。而经过测试发现**UIImagePNGRepresentation**方法转换成**NSData**对象时，EXIF信息将会丢失，而**UIImageJPEGRepresentation**方法则不会。在找到原因之后，问题就可以很好的解决了，只要在加入到缓存之前，将图片恢复到正常方向，再将图片保存到缓存中即可。  \n\n### 获取缓存失败\n本以为问题都解决了，然而第二天我们测试发现在一些情况下，插入图片时会显示一张默认图片（图片如果加载失败会显示一张默认的小图），在跟测试MM做了一些沟通之后，走读了一下代码流程，并进行了调试，发现图片被放进缓存之后，再次进行获取时，却获取不到数据。  \n\n想不通为什么，于是看了一下**SDImageCache**类的源码（前面有提到），结合调试发现的一些信息，在加载iPad（我们的应用是iPad）拍摄的照片并且在插入多张图片之后才会出现这种现象，于是猜想是不是在**UIImage**对象在加入到缓存中之后，这时候收到内存警告或者超过设定的阀值，导致被加入的对象在IO线程还未将图片写入到磁盘之前就被释放了，这样将导致从内存和磁盘中都获取不到数据。为了验证这个猜想，修改了**SDImageCache**源码，设置了memCache的delegate，**NSCache**有个delegate，协议如下：\n\n```\n@protocol NSCacheDelegate <NSObject>\n@optional\n- (void)cache:(NSCache *)cache willEvictObject:(id)obj;\n@end\n```\n\n通过该protocol便可以知道被加入缓存中的对象什么时候被释放。在delegate中、IO线程中写入文件成功之后以及获取**UIImage**对象时添加一些Log信息。这样便可以知道各个逻辑的执行流程。经过验证，执行流程我猜想的一样，**UIImage**对象在加入到缓存一小会时间之后立马被释放了，这时候IO线程还未执行完成，这时候从缓存中是获取不到缓存数据的。从而导致失败显示默认图片。  \n\n问题已经找到了，但是要解决这个问题很是蛋疼，分别有以下几种做法：\n* 修改上层逻辑代码等待IO线程写入成功后，才执行后续流程，这样确保一定能获取到数据。\n* 修改**SDWebImage**让内存数据不那么快被释放。\n* 自己重新造个轮子达到我们想要的要求。\n\n对于上述修改第一条有点恶心，有点打补丁的节奏。针对后两条不太实际，工作量太大，最近在[**ibireme**](http://blog.ibireme.com/)的博客上看一个[**YYCache**](https://github.com/ibireme/YYCache)的开源项目，看了介绍还不错，于是将项目中的缓存直接换成了**YYCache**，做了相同的测试，发现问题没有出现了。^o^，后续将阅读一下**YYCache**的源代码了，看看具体的实现方法。\n\n### 总结\n在优化的过程中发现了**SDWebImage**的两个问题分别为：\n* 在使用**SDWebImage**做图片缓存时，图片默认会被当做PNG格式存储，而**UIImagePNGRepresentation**方法转换成**NSData**时会丢失EXIF信息，这样当再次从磁盘读取数据时，将是丢失EXIF信息的图片，从而导致无法进行正常的图片旋转。\n* 使用**SDWebImage**做缓存时，当内存到达一个临界值时，加入的新的缓存对象，会在IO线程写入文件之前释放，在内存对象被释放，IO未完成写入的这段时间内，无法正确获取到缓存数据。  \n\n[**SDWebImage**](https://github.com/rs/SDWebImage)很多人在用，而且使用起来也很方便，尤其在加载网络图片时非常方便，项目中还将继续使用用来做网络图片的加载，不过内存缓存会使用[**YYCache**](https://github.com/ibireme/YYCache)， 针对[**YYCache**](https://github.com/ibireme/YYCache)这个类，还没来得及细看代码，网上评价作者代码相当工整，看过[**YYCategories**](https://github.com/ibireme/YYCategories)部分源码实现，确实写的不错，今后多看看，向大牛们学习。\n\n\n\n\n\n\n\n\n\n","slug":"sdwebimage-issues","published":1,"updated":"2016-01-07T02:10:57.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj1a0t07y0003gdp1z69trdtu","sticky":0},{"title":"Protocol Buffer 简介与使用","date":"2017-02-17T06:58:27.000Z","_content":"\nProtocol Buffer(简称Protobuf或PB)是由 Google 开发的，原本用来解决索引服务器的请求、响应协议，后面才对外使用和开源的，它是一种数据交换格式，与 XML 和 JSON 相比 ，它是一种二进制格式，避免了各种文本格式转换的问题，并且更体积更小、速度更快使用更简单方便，还自带部分数据压缩功能，在网络传输时可以减少数据流量。同时它也是与平台和语言无关的，尤其在网络数据交换方面，使得它越来越流行。\n\nProtobuf 是一个开源项目，项目托管在 GitHub 上，链接为:[https://github.com/google/protobuf](https://github.com/google/protobuf)，源码包含两部分内容：\n\n* **PB基础库**：用来完成对象模型与数据模型之前的转换\n* **PB编译器**：源码生成器，用来将 *.proto* 文件转换成对应语言的对象模型的源码\n\nProtobuf 截止目前最新版本为 `3.2.0-alpha-1` 版本，在 `3.0.0` 版本之前也就是 `2.6.1` 版本时官方只支持 `C++/Java/Python` 三种语言，`3.0.0` 版本之后才逐步支持其他语言。在这之前如果其他语言需要用到 Protobuf 都是通过第三方扩展来实现的，目前官方以及支持以下编程语言：\n\n<!--more-->\n\n| Language            | Source             |\n|---------------------|--------------------|\n| C++ (include C++ runtime and protoc) | [src](https://github.com/google/protobuf/blob/master/src)   |\n| Java                                 | [java](https://github.com/google/protobuf/blob/master/java)   |\n| Python                               | [python](https://github.com/google/protobuf/blob/master/python)  |\n| Objective-C                          | [objectivec](https://github.com/google/protobuf/blob/master/objectivec)  |\n| C#                                   | [csharp](https://github.com/google/protobuf/blob/master/csharp)  |\n| JavaNano                             | [javanano](https://github.com/google/protobuf/blob/master/javanano)  |\n| JavaScript                           | [js](https://github.com/google/protobuf/blob/master/js)  |\n| Ruby                                 | [ruby](https://github.com/google/protobuf/blob/master/ruby) |\n| Go                                   | [golang/protobuf](https://github.com/golang/protobuf) |\n| PHP                                  | [php](https://github.com/google/protobuf/blob/master/php)  |\n\n> 备注：后续将使用最新版本`3.2.0-alpha-1 `以及 Objective-C 语言作为示例\n\n### Protobuf 编译器\n\nProtobuf 编译器在于将 *.proto* 文件转成对应语言的对象模型的源代码，可以从 GitHub 上下载源代码在本地进行编译，然后生成 Protobuf 编译器，也可以从 GitHub 上下载已经编译好的编译器。\n\n下载链接为：[https://github.com/google/protobuf/releases](https://github.com/google/protobuf/releases)\n\n如果是源码的话执行以下命令进行编译：\n\n```\ncd Source code 目录\n./configure\nmake\nmake check\nsudo make install\n\n```\n\n如果编译成功，就可以使用 `proto` 命令了，如果是直接下载的 `proto` 文件，就不需要编译可直接运行。我们可以创建一个 *.proto* 文件来测试一下环境是否搭建好，样例文件如下：\n\n```\nmessage User\n{\n  required int32 uid = 1;        // 用户唯一标识\n  required string nickname = 2;  // 用户昵称\n  required int32 age = 3;        // 用户年龄\n}\n```\n\n如果需要生成 Objective-C 源文件的话，执行以下命令即可：\n\n```\nprotoc --objc_out=./ ./test.proto\n```\n\n如果环境正常的话，可以在当前目录下生成 *Test.pbobjc.h* 和 *Test.pbobjc.m* 两个文件，由于 Protobuf 编译器生成的 Objective-C 源文件是基于 MRC 的，所以如果在 ARC 工程成需要添加 `-fno-objc-arc` 标签，否则无法通过编译。\n\n### Protobuf 基础库\n\nProtobuf 基础库是用来做对象的序列化以及反序列化用的库，也可以从以下地址下载基础库的载源码：\n\n下载链接为：[https://github.com/google/protobuf/releases](https://github.com/google/protobuf/releases)\n\n将下载好的源码拖到对应的工程中即可，同样需要注意的是基础库的源码也是基于 MRC 的，所以也得添加 `-fno-objc-arc` 标签。同时必须保证基础库和编译器的版本一致，否则也会导致工程无法正常编译。\n\n基础库在 iOS 项目中也可以使用 **cocoapods** 方式引入，只要在 `Podfile` 中添加：\n\n```\n# 当前工程支持的 SDK 版本\nplatform :ios, '7.1'\npod 'Protobuf', '~> 3.1.0'\n\n```\n\n### 在项目中使用 Protobuf\n\n将编译器生成的对象的源文件以及基础库导入到工程后，我们就可以使用它们了，示例如下：\n\n```\n// 创建一个 User 对象\nUser *user = [[User alloc] init];\nuser.uid = 10086;\nuser.nickname = @\"EnkiChen\";\nuser.age = 28;\n    \n// 序列化为 Data\nNSData *data = [user data];\n    \n// 反序列化为对象\nUser *us = [User parseFromData:data error:NULL];\nNSLog(@\"uid:%d nickname:%@ age:%d\", us.uid, us.nickname, us.age);\n\n```\n\n### Protobuf 的优缺点\n\n#### 优点\n\n* **性能好/效率高**： 相比于 XML 和 JSON 而言，Protobuf 序列化反序列化速度很快，生成的数据体积更小，适合网络传输\n* **有代码生成机制**：可以由编译器自动生成对应语言的类对象文件，无需自己编写解析代码\n* **支持向后/向前兼容**：所谓的“向后兼容”（backward compatible），就是说，当模块 B 升级了之后，它能够正确识别模块 A 发出的老版本的协议。 所谓的“向前兼容”（forward compatible），就是说，当模块A升级了之后，模块 B 能够正常识别模块 A 发出的新版本的协议。\n* **支持多种语言跨平台**：如上文所提到，官方已经支持多种主流语言，并且跨平台\n\n#### 缺点\n\n* **可读性差**：相对于 XML 和 JSON 而言，对象序列化后生成的数据可读性差（二进制格式）\n* **缺乏自描述**：XML 和 JSON 是自描述的，而 Protobuf 格式则不是。一段 Protobuf 格式的二进制数据内容，不配合 *.proto* 文件结构体是看不出来什么作用的。\n\n对于 *.proto* 文件的编写规则及语法等内容就不介绍了，后续有时间再补上。","source":"_posts/protobuf-introduce.md","raw":"title: Protocol Buffer 简介与使用\ndate: 2017-02-17 14:58:27\ncategories: 知识整理/总结\ntags: [Protobuf]\n---\n\nProtocol Buffer(简称Protobuf或PB)是由 Google 开发的，原本用来解决索引服务器的请求、响应协议，后面才对外使用和开源的，它是一种数据交换格式，与 XML 和 JSON 相比 ，它是一种二进制格式，避免了各种文本格式转换的问题，并且更体积更小、速度更快使用更简单方便，还自带部分数据压缩功能，在网络传输时可以减少数据流量。同时它也是与平台和语言无关的，尤其在网络数据交换方面，使得它越来越流行。\n\nProtobuf 是一个开源项目，项目托管在 GitHub 上，链接为:[https://github.com/google/protobuf](https://github.com/google/protobuf)，源码包含两部分内容：\n\n* **PB基础库**：用来完成对象模型与数据模型之前的转换\n* **PB编译器**：源码生成器，用来将 *.proto* 文件转换成对应语言的对象模型的源码\n\nProtobuf 截止目前最新版本为 `3.2.0-alpha-1` 版本，在 `3.0.0` 版本之前也就是 `2.6.1` 版本时官方只支持 `C++/Java/Python` 三种语言，`3.0.0` 版本之后才逐步支持其他语言。在这之前如果其他语言需要用到 Protobuf 都是通过第三方扩展来实现的，目前官方以及支持以下编程语言：\n\n<!--more-->\n\n| Language            | Source             |\n|---------------------|--------------------|\n| C++ (include C++ runtime and protoc) | [src](https://github.com/google/protobuf/blob/master/src)   |\n| Java                                 | [java](https://github.com/google/protobuf/blob/master/java)   |\n| Python                               | [python](https://github.com/google/protobuf/blob/master/python)  |\n| Objective-C                          | [objectivec](https://github.com/google/protobuf/blob/master/objectivec)  |\n| C#                                   | [csharp](https://github.com/google/protobuf/blob/master/csharp)  |\n| JavaNano                             | [javanano](https://github.com/google/protobuf/blob/master/javanano)  |\n| JavaScript                           | [js](https://github.com/google/protobuf/blob/master/js)  |\n| Ruby                                 | [ruby](https://github.com/google/protobuf/blob/master/ruby) |\n| Go                                   | [golang/protobuf](https://github.com/golang/protobuf) |\n| PHP                                  | [php](https://github.com/google/protobuf/blob/master/php)  |\n\n> 备注：后续将使用最新版本`3.2.0-alpha-1 `以及 Objective-C 语言作为示例\n\n### Protobuf 编译器\n\nProtobuf 编译器在于将 *.proto* 文件转成对应语言的对象模型的源代码，可以从 GitHub 上下载源代码在本地进行编译，然后生成 Protobuf 编译器，也可以从 GitHub 上下载已经编译好的编译器。\n\n下载链接为：[https://github.com/google/protobuf/releases](https://github.com/google/protobuf/releases)\n\n如果是源码的话执行以下命令进行编译：\n\n```\ncd Source code 目录\n./configure\nmake\nmake check\nsudo make install\n\n```\n\n如果编译成功，就可以使用 `proto` 命令了，如果是直接下载的 `proto` 文件，就不需要编译可直接运行。我们可以创建一个 *.proto* 文件来测试一下环境是否搭建好，样例文件如下：\n\n```\nmessage User\n{\n  required int32 uid = 1;        // 用户唯一标识\n  required string nickname = 2;  // 用户昵称\n  required int32 age = 3;        // 用户年龄\n}\n```\n\n如果需要生成 Objective-C 源文件的话，执行以下命令即可：\n\n```\nprotoc --objc_out=./ ./test.proto\n```\n\n如果环境正常的话，可以在当前目录下生成 *Test.pbobjc.h* 和 *Test.pbobjc.m* 两个文件，由于 Protobuf 编译器生成的 Objective-C 源文件是基于 MRC 的，所以如果在 ARC 工程成需要添加 `-fno-objc-arc` 标签，否则无法通过编译。\n\n### Protobuf 基础库\n\nProtobuf 基础库是用来做对象的序列化以及反序列化用的库，也可以从以下地址下载基础库的载源码：\n\n下载链接为：[https://github.com/google/protobuf/releases](https://github.com/google/protobuf/releases)\n\n将下载好的源码拖到对应的工程中即可，同样需要注意的是基础库的源码也是基于 MRC 的，所以也得添加 `-fno-objc-arc` 标签。同时必须保证基础库和编译器的版本一致，否则也会导致工程无法正常编译。\n\n基础库在 iOS 项目中也可以使用 **cocoapods** 方式引入，只要在 `Podfile` 中添加：\n\n```\n# 当前工程支持的 SDK 版本\nplatform :ios, '7.1'\npod 'Protobuf', '~> 3.1.0'\n\n```\n\n### 在项目中使用 Protobuf\n\n将编译器生成的对象的源文件以及基础库导入到工程后，我们就可以使用它们了，示例如下：\n\n```\n// 创建一个 User 对象\nUser *user = [[User alloc] init];\nuser.uid = 10086;\nuser.nickname = @\"EnkiChen\";\nuser.age = 28;\n    \n// 序列化为 Data\nNSData *data = [user data];\n    \n// 反序列化为对象\nUser *us = [User parseFromData:data error:NULL];\nNSLog(@\"uid:%d nickname:%@ age:%d\", us.uid, us.nickname, us.age);\n\n```\n\n### Protobuf 的优缺点\n\n#### 优点\n\n* **性能好/效率高**： 相比于 XML 和 JSON 而言，Protobuf 序列化反序列化速度很快，生成的数据体积更小，适合网络传输\n* **有代码生成机制**：可以由编译器自动生成对应语言的类对象文件，无需自己编写解析代码\n* **支持向后/向前兼容**：所谓的“向后兼容”（backward compatible），就是说，当模块 B 升级了之后，它能够正确识别模块 A 发出的老版本的协议。 所谓的“向前兼容”（forward compatible），就是说，当模块A升级了之后，模块 B 能够正常识别模块 A 发出的新版本的协议。\n* **支持多种语言跨平台**：如上文所提到，官方已经支持多种主流语言，并且跨平台\n\n#### 缺点\n\n* **可读性差**：相对于 XML 和 JSON 而言，对象序列化后生成的数据可读性差（二进制格式）\n* **缺乏自描述**：XML 和 JSON 是自描述的，而 Protobuf 格式则不是。一段 Protobuf 格式的二进制数据内容，不配合 *.proto* 文件结构体是看不出来什么作用的。\n\n对于 *.proto* 文件的编写规则及语法等内容就不介绍了，后续有时间再补上。","slug":"protobuf-introduce","published":1,"updated":"2017-02-17T07:04:31.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj1a0t089000cgdp1vh2q2nrk","sticky":0},{"title":"iOS下使用OpenGL要注意的几点","date":"2015-12-29T08:59:49.000Z","_content":"\n因为项目中使用到了OpenGL ES做绘图，记录一下一些要注意的点：  \n\n* *glGenTextures()*方法申请到的纹理对象ID，会由系统控制其对象的释放（也可以使用*glDeleteTextures()*进行手动释放），所以在使用之前需要使用*glIsTexture()*来检测该纹理ID是否可用，当为false时，需要重新生成纹理对象ID，如果继续使用该纹理ID，会无法绘制从而导致绘制时为纯白色。  \n<!--more-->\n* iOS下不同的硬件设备，最大的纹理大小是有限制的，如下表（来源于网络）：\n\n\n  | 1024 x 1024 | 2048 x 2048 | 4096 x 4096 |\n  |    :--:     |     :--:    |    :--:     |\n  | iPhone 2G   | iPhone 3gs  | iPhone 4s   |\n  | iPhone 3G   | iPhone 4    | iPad 2      |\n  |             | iPad        | iPad 3      |\n\n\n* 我在最新的iPad Air上测试发现最大也支持4096x4096，所以结合上表来看，从iPhone4S和iPad2开始，到最新的iPhone6s以及最新的iPad Air最大也只能支持4096x4096的大小。所以在使用时要注意，否则会导致无法渲染而变成纯白色。  \n* 在使用OpenGL时纹理图片的宽高都需要是2的N次方，在一些平台下（PC平台）下没有这样的限制。并且纹理图片不需要非得是正方形的。所以在使用一些不符合大小时，需要手动对图片进行拉伸，然后复制到显存中进行关联，在进行绘制时按对应的坐标进行转换，所以并不用担心图片在渲染时会被拉伸的问题。\n\n> 我使用的是OpenGL ES 1.x的版本，第一条我在网上没找到太多的资料，都是通过测试发现的，如果有什么不对，还请指正，谢谢。","source":"_posts/ios-xia-opengl-xu-yao-zhu-yi-de-ji-dian.md","raw":"title: iOS下使用OpenGL要注意的几点\ndate: 2015-12-29 16:59:49\ncategories: 开发笔记\ntags: [OpenGL, 纹理]\n---\n\n因为项目中使用到了OpenGL ES做绘图，记录一下一些要注意的点：  \n\n* *glGenTextures()*方法申请到的纹理对象ID，会由系统控制其对象的释放（也可以使用*glDeleteTextures()*进行手动释放），所以在使用之前需要使用*glIsTexture()*来检测该纹理ID是否可用，当为false时，需要重新生成纹理对象ID，如果继续使用该纹理ID，会无法绘制从而导致绘制时为纯白色。  \n<!--more-->\n* iOS下不同的硬件设备，最大的纹理大小是有限制的，如下表（来源于网络）：\n\n\n  | 1024 x 1024 | 2048 x 2048 | 4096 x 4096 |\n  |    :--:     |     :--:    |    :--:     |\n  | iPhone 2G   | iPhone 3gs  | iPhone 4s   |\n  | iPhone 3G   | iPhone 4    | iPad 2      |\n  |             | iPad        | iPad 3      |\n\n\n* 我在最新的iPad Air上测试发现最大也支持4096x4096，所以结合上表来看，从iPhone4S和iPad2开始，到最新的iPhone6s以及最新的iPad Air最大也只能支持4096x4096的大小。所以在使用时要注意，否则会导致无法渲染而变成纯白色。  \n* 在使用OpenGL时纹理图片的宽高都需要是2的N次方，在一些平台下（PC平台）下没有这样的限制。并且纹理图片不需要非得是正方形的。所以在使用一些不符合大小时，需要手动对图片进行拉伸，然后复制到显存中进行关联，在进行绘制时按对应的坐标进行转换，所以并不用担心图片在渲染时会被拉伸的问题。\n\n> 我使用的是OpenGL ES 1.x的版本，第一条我在网上没找到太多的资料，都是通过测试发现的，如果有什么不对，还请指正，谢谢。","slug":"ios-xia-opengl-xu-yao-zhu-yi-de-ji-dian","published":1,"updated":"2016-01-07T02:25:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj1a0t08c000hgdp13fbkl85m","sticky":0},{"title":"iOS开发者证书以及代码签名学习笔记","date":"2016-01-15T09:47:06.000Z","_content":"\n> 最近需要给iOS开发团队做一次关于iOS开发证书以及代码签名的分享，于是花了点时间把这一块的知识重新学习和整理了一遍，从而有了这篇学习笔记。其中很多一些文字都是从网站或者博客上摘抄过来，为了阅读方便也做了一些调整，说白了我只是做了一些知识的梳理和整合。  \n\n> 该笔记涉及到内容有：开发者账号、签名证书、标识符（Identifiers）、设备（Devices）、APP授权机制、配置文件、ipa文件的签名和安全验证。\n\n<!--more-->\n\n### 开发者账号类型\n\n苹果为iOS开发者提供三种账号类型，如下：\n\n* **Apple Developer Program** 年费 $99(或¥688) 可以在iOS App Store和Mac App Store上架应用可以以个人（Individual）或者组织（Organization）的名义加入，以组织身份加入需要提供邓白氏编码（DUNS Number），会多出Team Management功能，允许多人协作开发。在发布署名上以组织（Organization）的名义加入可以填写公司或组织信息（比如某某公司、某某工作室），而以个人（Individual）加入只能默认显示注册时填写的个人信息，并且不能修改。\n* **Apple Developer Enterprise Program**年费 $299，用于以InHouse方式发布企业内部应用，不能上架App Store企业证书过期则已经安装的应用无法继续运行。\n* **iOS Developer University Program**\n高校计划需要提供高校基本信息，免费提供。苹果为鼓励高校更多的参与到苹果开发者计划中来，特意推出这一项计划，高校计划具有在真机上测试等权限，但不能将App发布到App Store。\n\n### 证书（Certificates）\n\n什么是证书？证书就是：证明证书拥有者有证书上所说的能力，一个证书要涉及到颁发者、拥有者、证明拥有者有了什么能力。例如，CET-4证书；颁发者：学校，拥有者：自己，证明的能力：英语达到四级水平。苹果开发者证书也是一样，颁发者：自己，拥有者：安装证书的电脑；证明的能力：可以打包某应用程序。  \n\n#### 开发者证书能力来源\n\n向Member Center申请证书的过程，其实就是将在本地生成的`certSigningRequest`文件提交给苹果，让它进行签名授权的过程。`certSigningRequest`这个文件包含以下内容：\n\n1. 申请者信息。\n2. 申请者公钥，此信息是申请者使用的私钥对应的公钥。\n3. 摘要算法和公钥加密算法。\n4. 当前文件摘要的签名（使用的是该文件中公钥对应的私钥进行签名的）。\n\n当苹果用私钥对其签名（授权）之后，我们便可以获得一个证书文件。拥有该证书后，我们便可以用对应的私钥对APP签名了。当iOS设备拿到APP时便可以通过证书中的公钥来验证APP的正确性，同时iOS设备本身可以验证证书的是否被授权，因为该证书是苹果自己签名的证书。\n\n> 被苹果签名的证书会随APP一起打包到ipa文件中，并提交到App store中。\n\n当我们获得签名证书之后，还需要一个证书来验证证书是否被正确授权，该证书就是Worldwide Developer Relations Certificate Authority证书。该证书一般都会随Xcode一起安装到我们的电脑中，也可以从Member Center去下载。所以如果没有该证书，开发者将不能使用对应的私钥对APP的签名，因为不能确保证书是否被授权。该证书也就是网上有提到媒介证书（Intermediate Certificate）。\n\n#### 证书的类型\n\n苹果为开发者提供三种证书类型，用来在不同环境下使用，方便开发者的调试和测试。\n\n* **开发证书**：平时用来进行真机调试的证书，用该证书签名的APP，只能安装在指定的设备上。\n* **测试证书**：不可以用来真机调试的证书，但是可以编译到指定的真机上（不可以进行调试）。主要用来提交给测试进行功能的验证，和**开发证书**的区别在于，它和**发布证书**类似处于非沙盒坏境。但是用该证书签名的APP无法提交到App store，只能安装在指定设备上。  \n* **发布证书**：不可以用来调试和测试，也不能安装在指定设备上，只能提交到App store。\n\n> 使用**企业（Enterprise）**账号下的**发布证书**签名的APP可以安装到所以设备上，但是不能提交到App store。\n\n### 标识符（Identifiers）\n\n在Member Center中，Identifiers可以管理App IDs、Pass Type IDs、Website Push IDs、iCloud Containers、App Groups、Merchant IDs、这里主要介绍App IDs。  \n\nApp ID其实就是一个字符串，用来做APP唯一标识的字符串，App ID是大小写敏感的。一个APP有且只能有一个ID，并且唯一。在Project中称为Bundle ID（但是会有些小差别，Bundle ID不能包含**[ * ]**号）。在Member Center、Project、iTunes Connect都是需要此ID去标示此App的唯一性。App ID添加之后不能进行修改和删除。\n\n#### App ID字符的组成和类型\n\n![](http://www.enkichen.com/uploads/3.png)\n\n如上图所示，App ID由Apple产生的一个Team ID作为前缀，后面跟的是开发者自定义的标识符，App ID字符串中只能包含字符（A-Z，a-z，0-9），连接符（-），点（.）而且此字符串最好是reverse-DNS格式的。例如你公司的域名是cctv.com，你App的名字是Hello，那么你可以用com.cctv.Hello作为你的Bundle ID。\n\nApp ID中也可以以**[ .* ]**来结尾，用来表示一个通配类型，如图：\n\n![](http://www.enkichen.com/uploads/4.png)\n\n* 精准类型的App ID：在标识符中不带**[ .* ]**来结尾的App ID可以称作为精准类型，该类型的App ID可以用来做APP的Bundle ID。\n* 通配符类型App ID：在标识符中以**[ .* ]**结尾的App ID为通配符类型的App ID，该类型的App ID不能用来做APP的Bundle ID，其作用后续会讲到。\n\n> 每个APP还会对应一串数字的字符串（在**itunesconnect**创建之后可以得到），通过该字符串可以向Apple提供的http接口（http://itunes.apple.com/lookup?id=**），获取对应的APP在App store上的信息，可以用来检测版本更新，更新的log一些其他资料。\n\n#### App ID的作用\n\n* 在Xcode工程中，Bundle ID储存在Info.plist中，当你编译工程的时候，他会把此文件拷贝到你的app包中。  \n* 在iTunes Connect，用Bundle ID去标识App，在你第一次构建上传之后，你就不能在改变或者删除你的Bundle ID了。  \n* 在Member Center，你创建一个和Bundle ID相匹配的App ID。如果App ID是精准类型的，你就必须精确的去匹配你的Bundle ID。  \n\n### 授权机制 (Entitlements)\n\n授权机制决定了哪些系统资源在什么情况下允许被一个应用使用。简单的说它就是一个沙盒的配置列表，上面列出了哪些行为被允许，哪些会被拒绝。Xcode 会将这个文件作为`--entitlements`参数的内容传给 **codesign**。\n\n在 Xcode 的 Capabilities 选项卡下选择一些选项之后，Xcode 就会生成这样一段 XML。 Xcode 会自动生成一个 .entitlements 文件，然后在需要的时候往里面添加条目。当构建整个应用时，这个文件也会提交给 **codesign** 作为应用所需要拥有哪些授权的参考。这些授权信息必须都在开发者中心的 App ID 中启用，并且包含在配置文件中。\n\n> 授权列表在Member Center中的**App ID**中配置，这样便可以对应到具体的APP。\n\n### 设备（Devices）\n\n这里的Device指的就是用来测试或者调试用的设备。可以是iPhone、iPad、iPod、Apple watch以及Apple TV，在Member Center中添加测试Device的步骤其实很简单，只要拿到对应Deveice的UDID就可以添加了。我们可以利用iTunes、iTools、Xcode这些工具都可以拿到设备的UDID。\n\n> 需要注意的就是，每个开发者账号，每年最多可以添加100台调试设备，而且添加之后不能更改和删除，想要修改就要等到下一年重新续费的时候才能进行修改或者删除调试设备了。\n\n### 配置文件（Provisioning Profiles）\n\n上述提到了证书可以证明APP的所属以及APP的完整性，保证APP的本身的安全。但是却不能细化到APP所使用的服务被苹果认可，比如APN推送服务，并且证书无法限制调试版APP的装机规模。于是苹果想出了`mobileprovision `。一个`mobileprovision `文件包含一下内容：\n\n1. **AppID** 这里的AppId可以是精准类型的也可以是通配符类型。\n2. **证书列表** 在多人协议开发时，一个`mobileprovision `文件中可以包含多个证书文件。\n3. **功能授权列表**\n4. **可安装的设备列表** 测试和调试`mobileprovision `文件中包含设备列表，`mobileprovision `发布类型的文件中则不包含设备列表。\n5. **苹果的签名**\n\n> 上述提到的**苹果的签名**是用的苹果自己的私钥对应的公钥是Worldwide Developer Relations Certificate Authority证书（媒介证书）中的公钥，所以该文件生成后，我们是不能进行修改的，必须从Member Center中配置并生成。\n\n#### 配置文件的区分\n\n* 从`mobileprovision `文件中是否包含设备列表，可以分为带device信息的描述文件和不带device信息的描述文件如图：\n\n![](http://www.enkichen.com/uploads/1451875454246244.png)  \n\n![](http://www.enkichen.com/uploads/1451875469811263.png) \n\n* 也可以根据配置文件中包含的证书文件的类型来区分：**开发类型**、**测试类型**、**发布类型**。  \n\n* 也可以根据配置文件中包含的App ID来做区分，如果文件中App ID是精准类型的，那么该配置只能用来对指定的APP进行使用。如果是通配类型的，那么该证书可以用来对匹配的Bundle ID的APP进行使用。如果是Company类型的开发者账号，可以生成一个供团队使用的Team Provisioning Profile，通过这个配置文件，团队内成员可以共用一个配置文件来进行开发调试，当然，App ID得指定成通配类型的。`mobileprovision `文件结构如下：\n\n![](http://www.enkichen.com/uploads/5.png)  \n\n总的来说描述文件就是整合了**证书**、**AppID**、**设备**以及**功能授权列表**，从而确定了可由哪台电脑，把哪个App，安装到哪台手机上面。\n\n### APP的签名和安全验证过程\n\n#### ipa文件的签名过程\n\n这张图阐述了，开发iOS应用程序时，从申请证书，到打包的大致过程。\n\n![](http://www.enkichen.com/uploads/iOS证书和校验.png)\n\n#### ipa文件的组成\n\niOS程序最终都会以.ipa文件导出，ipa文件只是一个zip包，可以直接解压，先来了解一下ipa文件的结构：\n\n![](http://www.enkichen.com/uploads/ipa组成.png)\n\n解压后，得到上图的Payload目录，下面是个子目录，其中的内容如下：\n\n* 资源文件，例如图片、html、等等。\n* _CodeSignature/CodeResources。这是一个plist文件，可用文本查看，其中的内容就是是程序包中（不包括Frameworks）所有文件的签名。注意这里是所有文件。意味着你的程序一旦签名，就不能更改其中任何的东西，包括资源文件和可执行文件本身。iOS系统会检查这些签名。\n* 可执行文件。此文件跟资源文件一样需要签名。\n* 一个mobileprovision文件.打包的时候使用的，从MC上生成的。\n* Frameworks。程序引用的非系统自带的Frameworks，每个Frameworks其实就是一个app，其中的结构应该和app差不多，也包含签名信息CodeResources文件。\n\n#### ipa文件的安全验证过程\n\n1. 解压ipa文件\n2. 取出embedded.mobileprovision，通过签名校验是否被篡改过 a. 其中有几个证书的公钥，其中开发证书和发布证书用于校验签名 b. BundleId c. 授权列表\n3. 校验所有文件的签名，包括Frameworks\n4. 比对Info.plist里面的BundleId是否符合embedded.mobileprovision文件中的\n\n### 其他涉及到的问题\n\n* 团队开发证书的管理\n* Xcode7下的免年费的真机调试\n\n### 总结\n\n当加入到苹果开发者计划之后，苹果通过证书来授权给开发者开发iOS应用，并提供了多种证书类型来满足不同的需求。为了保证APP的安全性和完整性，APP中所有的文件都将被签名。除非重新签名，否则不能对其做任何修改。\n\n`mobileprovision`文件是一个配置文件，由苹果签名后发布给开发者的。其中包含了**证书**、**App ID**、**设备列表**、**授权列表**。通过这些信息从而确定了可由哪台电脑，把哪个App，安装到哪台手机上面。所以**证书**和`mobileprovision`文件是签名和打包的两个必要文件。\n\n### 参考资料\n\n* [**不让苹果开发者账号折磨我**](http://www.cocoachina.com/ios/20160104/14859.html)    \n* [**苹果开发者账号那些事儿**](http://ryantang.me/blog/2013/09/03/apple-account-2/)  \n* [**漫谈iOS程序的证书和签名机制**](http://www.pchou.info/ios/2015/12/14/ios-certification-and-code-sign.html)\n* [**代码签名探析**](http://objccn.io/issue-17-2/)\n* [**iOS Code Signing 学习笔记**](http://www.cocoachina.com/ios/20141017/9949.html)\n\n","source":"_posts/ios-certification-and-code-sign-note.md","raw":"title: iOS开发者证书以及代码签名学习笔记  \ndate: 2016-01-15 17:47:06  \ncategories: 知识整理/总结  \ntags: [开发证书, 代码签名, mobileprovision, Provisioning Profiles, 开发者账号]\n---\n\n> 最近需要给iOS开发团队做一次关于iOS开发证书以及代码签名的分享，于是花了点时间把这一块的知识重新学习和整理了一遍，从而有了这篇学习笔记。其中很多一些文字都是从网站或者博客上摘抄过来，为了阅读方便也做了一些调整，说白了我只是做了一些知识的梳理和整合。  \n\n> 该笔记涉及到内容有：开发者账号、签名证书、标识符（Identifiers）、设备（Devices）、APP授权机制、配置文件、ipa文件的签名和安全验证。\n\n<!--more-->\n\n### 开发者账号类型\n\n苹果为iOS开发者提供三种账号类型，如下：\n\n* **Apple Developer Program** 年费 $99(或¥688) 可以在iOS App Store和Mac App Store上架应用可以以个人（Individual）或者组织（Organization）的名义加入，以组织身份加入需要提供邓白氏编码（DUNS Number），会多出Team Management功能，允许多人协作开发。在发布署名上以组织（Organization）的名义加入可以填写公司或组织信息（比如某某公司、某某工作室），而以个人（Individual）加入只能默认显示注册时填写的个人信息，并且不能修改。\n* **Apple Developer Enterprise Program**年费 $299，用于以InHouse方式发布企业内部应用，不能上架App Store企业证书过期则已经安装的应用无法继续运行。\n* **iOS Developer University Program**\n高校计划需要提供高校基本信息，免费提供。苹果为鼓励高校更多的参与到苹果开发者计划中来，特意推出这一项计划，高校计划具有在真机上测试等权限，但不能将App发布到App Store。\n\n### 证书（Certificates）\n\n什么是证书？证书就是：证明证书拥有者有证书上所说的能力，一个证书要涉及到颁发者、拥有者、证明拥有者有了什么能力。例如，CET-4证书；颁发者：学校，拥有者：自己，证明的能力：英语达到四级水平。苹果开发者证书也是一样，颁发者：自己，拥有者：安装证书的电脑；证明的能力：可以打包某应用程序。  \n\n#### 开发者证书能力来源\n\n向Member Center申请证书的过程，其实就是将在本地生成的`certSigningRequest`文件提交给苹果，让它进行签名授权的过程。`certSigningRequest`这个文件包含以下内容：\n\n1. 申请者信息。\n2. 申请者公钥，此信息是申请者使用的私钥对应的公钥。\n3. 摘要算法和公钥加密算法。\n4. 当前文件摘要的签名（使用的是该文件中公钥对应的私钥进行签名的）。\n\n当苹果用私钥对其签名（授权）之后，我们便可以获得一个证书文件。拥有该证书后，我们便可以用对应的私钥对APP签名了。当iOS设备拿到APP时便可以通过证书中的公钥来验证APP的正确性，同时iOS设备本身可以验证证书的是否被授权，因为该证书是苹果自己签名的证书。\n\n> 被苹果签名的证书会随APP一起打包到ipa文件中，并提交到App store中。\n\n当我们获得签名证书之后，还需要一个证书来验证证书是否被正确授权，该证书就是Worldwide Developer Relations Certificate Authority证书。该证书一般都会随Xcode一起安装到我们的电脑中，也可以从Member Center去下载。所以如果没有该证书，开发者将不能使用对应的私钥对APP的签名，因为不能确保证书是否被授权。该证书也就是网上有提到媒介证书（Intermediate Certificate）。\n\n#### 证书的类型\n\n苹果为开发者提供三种证书类型，用来在不同环境下使用，方便开发者的调试和测试。\n\n* **开发证书**：平时用来进行真机调试的证书，用该证书签名的APP，只能安装在指定的设备上。\n* **测试证书**：不可以用来真机调试的证书，但是可以编译到指定的真机上（不可以进行调试）。主要用来提交给测试进行功能的验证，和**开发证书**的区别在于，它和**发布证书**类似处于非沙盒坏境。但是用该证书签名的APP无法提交到App store，只能安装在指定设备上。  \n* **发布证书**：不可以用来调试和测试，也不能安装在指定设备上，只能提交到App store。\n\n> 使用**企业（Enterprise）**账号下的**发布证书**签名的APP可以安装到所以设备上，但是不能提交到App store。\n\n### 标识符（Identifiers）\n\n在Member Center中，Identifiers可以管理App IDs、Pass Type IDs、Website Push IDs、iCloud Containers、App Groups、Merchant IDs、这里主要介绍App IDs。  \n\nApp ID其实就是一个字符串，用来做APP唯一标识的字符串，App ID是大小写敏感的。一个APP有且只能有一个ID，并且唯一。在Project中称为Bundle ID（但是会有些小差别，Bundle ID不能包含**[ * ]**号）。在Member Center、Project、iTunes Connect都是需要此ID去标示此App的唯一性。App ID添加之后不能进行修改和删除。\n\n#### App ID字符的组成和类型\n\n![](http://www.enkichen.com/uploads/3.png)\n\n如上图所示，App ID由Apple产生的一个Team ID作为前缀，后面跟的是开发者自定义的标识符，App ID字符串中只能包含字符（A-Z，a-z，0-9），连接符（-），点（.）而且此字符串最好是reverse-DNS格式的。例如你公司的域名是cctv.com，你App的名字是Hello，那么你可以用com.cctv.Hello作为你的Bundle ID。\n\nApp ID中也可以以**[ .* ]**来结尾，用来表示一个通配类型，如图：\n\n![](http://www.enkichen.com/uploads/4.png)\n\n* 精准类型的App ID：在标识符中不带**[ .* ]**来结尾的App ID可以称作为精准类型，该类型的App ID可以用来做APP的Bundle ID。\n* 通配符类型App ID：在标识符中以**[ .* ]**结尾的App ID为通配符类型的App ID，该类型的App ID不能用来做APP的Bundle ID，其作用后续会讲到。\n\n> 每个APP还会对应一串数字的字符串（在**itunesconnect**创建之后可以得到），通过该字符串可以向Apple提供的http接口（http://itunes.apple.com/lookup?id=**），获取对应的APP在App store上的信息，可以用来检测版本更新，更新的log一些其他资料。\n\n#### App ID的作用\n\n* 在Xcode工程中，Bundle ID储存在Info.plist中，当你编译工程的时候，他会把此文件拷贝到你的app包中。  \n* 在iTunes Connect，用Bundle ID去标识App，在你第一次构建上传之后，你就不能在改变或者删除你的Bundle ID了。  \n* 在Member Center，你创建一个和Bundle ID相匹配的App ID。如果App ID是精准类型的，你就必须精确的去匹配你的Bundle ID。  \n\n### 授权机制 (Entitlements)\n\n授权机制决定了哪些系统资源在什么情况下允许被一个应用使用。简单的说它就是一个沙盒的配置列表，上面列出了哪些行为被允许，哪些会被拒绝。Xcode 会将这个文件作为`--entitlements`参数的内容传给 **codesign**。\n\n在 Xcode 的 Capabilities 选项卡下选择一些选项之后，Xcode 就会生成这样一段 XML。 Xcode 会自动生成一个 .entitlements 文件，然后在需要的时候往里面添加条目。当构建整个应用时，这个文件也会提交给 **codesign** 作为应用所需要拥有哪些授权的参考。这些授权信息必须都在开发者中心的 App ID 中启用，并且包含在配置文件中。\n\n> 授权列表在Member Center中的**App ID**中配置，这样便可以对应到具体的APP。\n\n### 设备（Devices）\n\n这里的Device指的就是用来测试或者调试用的设备。可以是iPhone、iPad、iPod、Apple watch以及Apple TV，在Member Center中添加测试Device的步骤其实很简单，只要拿到对应Deveice的UDID就可以添加了。我们可以利用iTunes、iTools、Xcode这些工具都可以拿到设备的UDID。\n\n> 需要注意的就是，每个开发者账号，每年最多可以添加100台调试设备，而且添加之后不能更改和删除，想要修改就要等到下一年重新续费的时候才能进行修改或者删除调试设备了。\n\n### 配置文件（Provisioning Profiles）\n\n上述提到了证书可以证明APP的所属以及APP的完整性，保证APP的本身的安全。但是却不能细化到APP所使用的服务被苹果认可，比如APN推送服务，并且证书无法限制调试版APP的装机规模。于是苹果想出了`mobileprovision `。一个`mobileprovision `文件包含一下内容：\n\n1. **AppID** 这里的AppId可以是精准类型的也可以是通配符类型。\n2. **证书列表** 在多人协议开发时，一个`mobileprovision `文件中可以包含多个证书文件。\n3. **功能授权列表**\n4. **可安装的设备列表** 测试和调试`mobileprovision `文件中包含设备列表，`mobileprovision `发布类型的文件中则不包含设备列表。\n5. **苹果的签名**\n\n> 上述提到的**苹果的签名**是用的苹果自己的私钥对应的公钥是Worldwide Developer Relations Certificate Authority证书（媒介证书）中的公钥，所以该文件生成后，我们是不能进行修改的，必须从Member Center中配置并生成。\n\n#### 配置文件的区分\n\n* 从`mobileprovision `文件中是否包含设备列表，可以分为带device信息的描述文件和不带device信息的描述文件如图：\n\n![](http://www.enkichen.com/uploads/1451875454246244.png)  \n\n![](http://www.enkichen.com/uploads/1451875469811263.png) \n\n* 也可以根据配置文件中包含的证书文件的类型来区分：**开发类型**、**测试类型**、**发布类型**。  \n\n* 也可以根据配置文件中包含的App ID来做区分，如果文件中App ID是精准类型的，那么该配置只能用来对指定的APP进行使用。如果是通配类型的，那么该证书可以用来对匹配的Bundle ID的APP进行使用。如果是Company类型的开发者账号，可以生成一个供团队使用的Team Provisioning Profile，通过这个配置文件，团队内成员可以共用一个配置文件来进行开发调试，当然，App ID得指定成通配类型的。`mobileprovision `文件结构如下：\n\n![](http://www.enkichen.com/uploads/5.png)  \n\n总的来说描述文件就是整合了**证书**、**AppID**、**设备**以及**功能授权列表**，从而确定了可由哪台电脑，把哪个App，安装到哪台手机上面。\n\n### APP的签名和安全验证过程\n\n#### ipa文件的签名过程\n\n这张图阐述了，开发iOS应用程序时，从申请证书，到打包的大致过程。\n\n![](http://www.enkichen.com/uploads/iOS证书和校验.png)\n\n#### ipa文件的组成\n\niOS程序最终都会以.ipa文件导出，ipa文件只是一个zip包，可以直接解压，先来了解一下ipa文件的结构：\n\n![](http://www.enkichen.com/uploads/ipa组成.png)\n\n解压后，得到上图的Payload目录，下面是个子目录，其中的内容如下：\n\n* 资源文件，例如图片、html、等等。\n* _CodeSignature/CodeResources。这是一个plist文件，可用文本查看，其中的内容就是是程序包中（不包括Frameworks）所有文件的签名。注意这里是所有文件。意味着你的程序一旦签名，就不能更改其中任何的东西，包括资源文件和可执行文件本身。iOS系统会检查这些签名。\n* 可执行文件。此文件跟资源文件一样需要签名。\n* 一个mobileprovision文件.打包的时候使用的，从MC上生成的。\n* Frameworks。程序引用的非系统自带的Frameworks，每个Frameworks其实就是一个app，其中的结构应该和app差不多，也包含签名信息CodeResources文件。\n\n#### ipa文件的安全验证过程\n\n1. 解压ipa文件\n2. 取出embedded.mobileprovision，通过签名校验是否被篡改过 a. 其中有几个证书的公钥，其中开发证书和发布证书用于校验签名 b. BundleId c. 授权列表\n3. 校验所有文件的签名，包括Frameworks\n4. 比对Info.plist里面的BundleId是否符合embedded.mobileprovision文件中的\n\n### 其他涉及到的问题\n\n* 团队开发证书的管理\n* Xcode7下的免年费的真机调试\n\n### 总结\n\n当加入到苹果开发者计划之后，苹果通过证书来授权给开发者开发iOS应用，并提供了多种证书类型来满足不同的需求。为了保证APP的安全性和完整性，APP中所有的文件都将被签名。除非重新签名，否则不能对其做任何修改。\n\n`mobileprovision`文件是一个配置文件，由苹果签名后发布给开发者的。其中包含了**证书**、**App ID**、**设备列表**、**授权列表**。通过这些信息从而确定了可由哪台电脑，把哪个App，安装到哪台手机上面。所以**证书**和`mobileprovision`文件是签名和打包的两个必要文件。\n\n### 参考资料\n\n* [**不让苹果开发者账号折磨我**](http://www.cocoachina.com/ios/20160104/14859.html)    \n* [**苹果开发者账号那些事儿**](http://ryantang.me/blog/2013/09/03/apple-account-2/)  \n* [**漫谈iOS程序的证书和签名机制**](http://www.pchou.info/ios/2015/12/14/ios-certification-and-code-sign.html)\n* [**代码签名探析**](http://objccn.io/issue-17-2/)\n* [**iOS Code Signing 学习笔记**](http://www.cocoachina.com/ios/20141017/9949.html)\n\n","slug":"ios-certification-and-code-sign-note","published":1,"updated":"2017-02-18T01:36:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj1a0t08g000ngdp1nvw45ief","sticky":0},{"title":"iOS 运行时之 Associative(关联)","date":"2017-02-18T04:42:00.000Z","_content":"\niOS 下有很多运行时特性，这里介绍一下 `Associative(关联)` 这个运行时特性，以及它一些使用场景。`Associative` 意思为关联，能够将两个对象建立一种关系。这种关系是一种 `从属` 关系，也就是说有一个 `关联者` 和一个 `被关联者`。比如说我们可以将一个 `NSString` 对象关联到一个 `UIView` 对象上。这里的 `NSString` 对象就是 `被关联者`, `UIView` 对象就是 `关联者`。\n\n在 `objc/runtime.h` 文件中，找到 `Associative ` 相关的 API 定义，如下：\n\n```\n/** \n * Sets an associated value for a given object using a given key and association policy.\n * \n * @param object The source object for the association.\n * @param key The key for the association.\n * @param value The value to associate with the key key for object. Pass nil to clear an existing association.\n * @param policy The policy for the association. For possible values, see “Associative Object Behaviors.”\n * \n * @see objc_setAssociatedObject\n * @see objc_removeAssociatedObjects\n */\nOBJC_EXPORT void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy)\n    OBJC_AVAILABLE(10.6, 3.1, 9.0, 1.0);\n\n/** \n * Returns the value associated with a given object for a given key.\n * \n * @param object The source object for the association.\n * @param key The key for the association.\n * \n * @return The value associated with the key \\e key for \\e object.\n * \n * @see objc_setAssociatedObject\n */\nOBJC_EXPORT id objc_getAssociatedObject(id object, const void *key)\n    OBJC_AVAILABLE(10.6, 3.1, 9.0, 1.0);\n\n/** \n * Removes all associations for a given object.\n * \n * @param object An object that maintains associated objects.\n * \n * @note The main purpose of this function is to make it easy to return an object \n *  to a \"pristine state”. You should not use this function for general removal of\n *  associations from objects, since it also removes associations that other clients\n *  may have added to the object. Typically you should use \\c objc_setAssociatedObject \n *  with a nil value to clear an association.\n * \n * @see objc_setAssociatedObject\n * @see objc_getAssociatedObject\n */\nOBJC_EXPORT void objc_removeAssociatedObjects(id object)\n    OBJC_AVAILABLE(10.6, 3.1, 9.0, 1.0);\n\n```\n<!--more-->\n同时还提供以下枚举类型的定义：\n\n```\n/**\n * Policies related to associative references.\n * These are options to objc_setAssociatedObject()\n */\ntypedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy) {\n    OBJC_ASSOCIATION_ASSIGN = 0,           /**< Specifies a weak reference to the associated object. */\n    OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, /**< Specifies a strong reference to the associated object. \n                                            *   The association is not made atomically. */\n    OBJC_ASSOCIATION_COPY_NONATOMIC = 3,   /**< Specifies that the associated object is copied. \n                                            *   The association is not made atomically. */\n    OBJC_ASSOCIATION_RETAIN = 01401,       /**< Specifies a strong reference to the associated object.\n                                            *   The association is made atomically. */\n    OBJC_ASSOCIATION_COPY = 01403          /**< Specifies that the associated object is copied.\n                                            *   The association is made atomically. */\n};\n```\n\n### API 解析\n\n`void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy)` API 为我们提供了将两个对象建立关联关系的能力，参数解析为：\n\n* **id object**：指定 `关联者`\n* **id value**：指定 `被关联者`\n* **const void *key**：`被关联者` 的 KEY 值，方便后续可以通过该 KEY 值找到该 `被关联者`\n* **objc_AssociationPolicy policy**: 该参数作用用来表示 `被关联者` 的引用策略，也就是内存如何进行管理的，可通过上述定义的枚举类型来设置。\n\n`id objc_getAssociatedObject(id object, const void *key)` API 可以通过之前设置的 KEY 值，来获取 `被关联者` 对象，参数解析如下：\n\n* **id object**：`关联者` 对象\n* **const void *key**：要获取的 `被关联者` 的 KEY 值，一个 `关联者` 可以被关联多对象，一个 `关联者` 也可以是 `被关联这`，可以通过不同的 KEY 来获取不同的 `被关联者` 对象。\n\n`void objc_removeAssociatedObjects(id object)` 该 API 可以移除一个 `关联者` 对象所有的 `被关联者`。当需要移除特定的对象时，我们可以使用 `objc_setAssociatedObject ` 方法并指定 `id value` 参数对象为空即可。\n\n以上就是关于 `Associative(关联)` 特性相关的 API 介绍了，下面介绍一下常用的使用场景。\n\n### Associative 特性的应用\n\n#### 剪切板的信息复制\n\n在一些时候我们希望用户可以长按文案信息，弹出系统的复制菜单，提供文案信息的复制功能，比如长按 \t`UITableViewCell` 提供复制详情的功能，在 iOS 下我们可以使用 `UIMenuController` 类来显示系统菜单，同时为该 `UITableViewCell` 添加长按手势，代码如下：\n\n```\n// 添加长按手势\nUILongPressGestureRecognizer *longPressGR = [[UILongPressGestureRecognizer alloc] initWithTarget:self action:@selector(handleLongPress:)];\n[cell addGestureRecognizer:longPressGR];\n\n// 手势处理\n- (void)handleLongPress:(UILongPressGestureRecognizer *) longPressGR {\n    UIMenuController *menu = [UIMenuController sharedMenuController];\n    [menu setTargetRect:longPressGR.view.frame inView:self.view];\n    [menu setMenuVisible:YES animated:YES];\n}\n\n// UIMenuController 相关\n- (BOOL)canBecomeFirstResponder {\n    return YES;\n}\n\n- (BOOL)canPerformAction:(SEL)action withSender:(id)sender {\n    if ( action == @selector(copy:) ) {\n        return YES;\n    }\n    return NO;\n}\n\n- (void)copy:(UIMenuController *)menu {\n    UIPasteboard *pasteboard = [UIPasteboard generalPasteboard];\n}\n```\n\n从上述代码可以看到，复制信息的逻辑处理是在 `copy:` 方法中，但是在该方法中，并不能访问到 `cell.detailTextLabel` 对象，在该场景中，我们可以使用 `Associative` 特性将 `UITableViewCell` 对象关联到 `UIMenuController` 对象中，再在 `copy:` 方法中获取到被关联对象，从而获取到 `UITableViewCell` 对象，进而访问 `cell.detailTextLabel.text`。添加代码如下：\n\n```\n// 处理手势时，添加如下代码\nobjc_setAssociatedObject(menu, @\"UITableViewCell\", longPressGR.view, OBJC_ASSOCIATION_RETAIN_NONATOMIC);\n\n// 处理 copy 时，添加如下代码，来获取被关联的 UITableViewCell 对象\nobjc_getAssociatedObject(menu, @\"UITableViewCell\");\npasteboard.string = cell.detailTextLabel.text;\n```\n\n上述场景中，并不一定非得用 `Associative` 特性来实现，还有很多可行的方法，这里为大家提供一种方法，并且该方法还算是比较优雅的。\n\n#### 其他一些应用场景\n\n另一个常见的应用场景就是，为一个系统类或是一个第三方的类添加一个属性时，可以结合 **Category** 为类添加一个属性，当然也可以使用继承来达到目的。在一些特殊场景下，比如想知道一个系统内部对象或者第三方对象是何时被释放时，我们可以为该对象关联一个自定义的对象，并且使用 `OBJC_ASSOCIATION_RETAIN_NONATOMIC ` 来指定内存管理策略，当关联者被释放是，被关联者也会跟着被释放，这样可以在我们自定义的对象中，知道感兴趣的对象何时被释放的。在调试一些内存问题时，该方法还是蛮有用的。","source":"_posts/ios-associative.md","raw":"title: iOS 运行时之 Associative(关联) \ndate: 2017-02-18 12:42:00  \ncategories: [知识整理/总结]  \ntags: [associative, runtime]\n---\n\niOS 下有很多运行时特性，这里介绍一下 `Associative(关联)` 这个运行时特性，以及它一些使用场景。`Associative` 意思为关联，能够将两个对象建立一种关系。这种关系是一种 `从属` 关系，也就是说有一个 `关联者` 和一个 `被关联者`。比如说我们可以将一个 `NSString` 对象关联到一个 `UIView` 对象上。这里的 `NSString` 对象就是 `被关联者`, `UIView` 对象就是 `关联者`。\n\n在 `objc/runtime.h` 文件中，找到 `Associative ` 相关的 API 定义，如下：\n\n```\n/** \n * Sets an associated value for a given object using a given key and association policy.\n * \n * @param object The source object for the association.\n * @param key The key for the association.\n * @param value The value to associate with the key key for object. Pass nil to clear an existing association.\n * @param policy The policy for the association. For possible values, see “Associative Object Behaviors.”\n * \n * @see objc_setAssociatedObject\n * @see objc_removeAssociatedObjects\n */\nOBJC_EXPORT void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy)\n    OBJC_AVAILABLE(10.6, 3.1, 9.0, 1.0);\n\n/** \n * Returns the value associated with a given object for a given key.\n * \n * @param object The source object for the association.\n * @param key The key for the association.\n * \n * @return The value associated with the key \\e key for \\e object.\n * \n * @see objc_setAssociatedObject\n */\nOBJC_EXPORT id objc_getAssociatedObject(id object, const void *key)\n    OBJC_AVAILABLE(10.6, 3.1, 9.0, 1.0);\n\n/** \n * Removes all associations for a given object.\n * \n * @param object An object that maintains associated objects.\n * \n * @note The main purpose of this function is to make it easy to return an object \n *  to a \"pristine state”. You should not use this function for general removal of\n *  associations from objects, since it also removes associations that other clients\n *  may have added to the object. Typically you should use \\c objc_setAssociatedObject \n *  with a nil value to clear an association.\n * \n * @see objc_setAssociatedObject\n * @see objc_getAssociatedObject\n */\nOBJC_EXPORT void objc_removeAssociatedObjects(id object)\n    OBJC_AVAILABLE(10.6, 3.1, 9.0, 1.0);\n\n```\n<!--more-->\n同时还提供以下枚举类型的定义：\n\n```\n/**\n * Policies related to associative references.\n * These are options to objc_setAssociatedObject()\n */\ntypedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy) {\n    OBJC_ASSOCIATION_ASSIGN = 0,           /**< Specifies a weak reference to the associated object. */\n    OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, /**< Specifies a strong reference to the associated object. \n                                            *   The association is not made atomically. */\n    OBJC_ASSOCIATION_COPY_NONATOMIC = 3,   /**< Specifies that the associated object is copied. \n                                            *   The association is not made atomically. */\n    OBJC_ASSOCIATION_RETAIN = 01401,       /**< Specifies a strong reference to the associated object.\n                                            *   The association is made atomically. */\n    OBJC_ASSOCIATION_COPY = 01403          /**< Specifies that the associated object is copied.\n                                            *   The association is made atomically. */\n};\n```\n\n### API 解析\n\n`void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy)` API 为我们提供了将两个对象建立关联关系的能力，参数解析为：\n\n* **id object**：指定 `关联者`\n* **id value**：指定 `被关联者`\n* **const void *key**：`被关联者` 的 KEY 值，方便后续可以通过该 KEY 值找到该 `被关联者`\n* **objc_AssociationPolicy policy**: 该参数作用用来表示 `被关联者` 的引用策略，也就是内存如何进行管理的，可通过上述定义的枚举类型来设置。\n\n`id objc_getAssociatedObject(id object, const void *key)` API 可以通过之前设置的 KEY 值，来获取 `被关联者` 对象，参数解析如下：\n\n* **id object**：`关联者` 对象\n* **const void *key**：要获取的 `被关联者` 的 KEY 值，一个 `关联者` 可以被关联多对象，一个 `关联者` 也可以是 `被关联这`，可以通过不同的 KEY 来获取不同的 `被关联者` 对象。\n\n`void objc_removeAssociatedObjects(id object)` 该 API 可以移除一个 `关联者` 对象所有的 `被关联者`。当需要移除特定的对象时，我们可以使用 `objc_setAssociatedObject ` 方法并指定 `id value` 参数对象为空即可。\n\n以上就是关于 `Associative(关联)` 特性相关的 API 介绍了，下面介绍一下常用的使用场景。\n\n### Associative 特性的应用\n\n#### 剪切板的信息复制\n\n在一些时候我们希望用户可以长按文案信息，弹出系统的复制菜单，提供文案信息的复制功能，比如长按 \t`UITableViewCell` 提供复制详情的功能，在 iOS 下我们可以使用 `UIMenuController` 类来显示系统菜单，同时为该 `UITableViewCell` 添加长按手势，代码如下：\n\n```\n// 添加长按手势\nUILongPressGestureRecognizer *longPressGR = [[UILongPressGestureRecognizer alloc] initWithTarget:self action:@selector(handleLongPress:)];\n[cell addGestureRecognizer:longPressGR];\n\n// 手势处理\n- (void)handleLongPress:(UILongPressGestureRecognizer *) longPressGR {\n    UIMenuController *menu = [UIMenuController sharedMenuController];\n    [menu setTargetRect:longPressGR.view.frame inView:self.view];\n    [menu setMenuVisible:YES animated:YES];\n}\n\n// UIMenuController 相关\n- (BOOL)canBecomeFirstResponder {\n    return YES;\n}\n\n- (BOOL)canPerformAction:(SEL)action withSender:(id)sender {\n    if ( action == @selector(copy:) ) {\n        return YES;\n    }\n    return NO;\n}\n\n- (void)copy:(UIMenuController *)menu {\n    UIPasteboard *pasteboard = [UIPasteboard generalPasteboard];\n}\n```\n\n从上述代码可以看到，复制信息的逻辑处理是在 `copy:` 方法中，但是在该方法中，并不能访问到 `cell.detailTextLabel` 对象，在该场景中，我们可以使用 `Associative` 特性将 `UITableViewCell` 对象关联到 `UIMenuController` 对象中，再在 `copy:` 方法中获取到被关联对象，从而获取到 `UITableViewCell` 对象，进而访问 `cell.detailTextLabel.text`。添加代码如下：\n\n```\n// 处理手势时，添加如下代码\nobjc_setAssociatedObject(menu, @\"UITableViewCell\", longPressGR.view, OBJC_ASSOCIATION_RETAIN_NONATOMIC);\n\n// 处理 copy 时，添加如下代码，来获取被关联的 UITableViewCell 对象\nobjc_getAssociatedObject(menu, @\"UITableViewCell\");\npasteboard.string = cell.detailTextLabel.text;\n```\n\n上述场景中，并不一定非得用 `Associative` 特性来实现，还有很多可行的方法，这里为大家提供一种方法，并且该方法还算是比较优雅的。\n\n#### 其他一些应用场景\n\n另一个常见的应用场景就是，为一个系统类或是一个第三方的类添加一个属性时，可以结合 **Category** 为类添加一个属性，当然也可以使用继承来达到目的。在一些特殊场景下，比如想知道一个系统内部对象或者第三方对象是何时被释放时，我们可以为该对象关联一个自定义的对象，并且使用 `OBJC_ASSOCIATION_RETAIN_NONATOMIC ` 来指定内存管理策略，当关联者被释放是，被关联者也会跟着被释放，这样可以在我们自定义的对象中，知道感兴趣的对象何时被释放的。在调试一些内存问题时，该方法还是蛮有用的。","slug":"ios-associative","published":1,"updated":"2017-02-18T05:03:04.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj1a0t08k000zgdp1gnx76vkd","sticky":0},{"title":"HTTP 之 Content-Type","date":"2016-08-29T12:27:25.000Z","_content":"\n在移动端开发中 HTTP 协议经常被用到，但是在面试或者工作中问到客户端和服务器传输业务数据，使用的数据的封装格式是什么以及怎么被封装到 HTTP 协议中时，很少有人能讲明白。\n\n在移动开发中 HTTP 协议为客户端到服务器端，提供了一条数据通道，能够将我们的业务数据传输到服务器，并且从服务器上获取响应数据。在 HTTP 协议头中的 **Content-Type** 字段描述了 **HTTP** 的 **BODY** 体的数据格式，而在 **BODY** 中可以定义我们业务数据的数据格式。**Content-Type** 字段可以用很多种类型，具体有哪些可以看 [**这里**](http://tool.oschina.net/commons)，并且也可以根据自身业务来自定义，不过这种做法比较少。这次我主要讲解三种格式分别为 **application/x-www-form-urlencoded**、**application/json** 以及 **multipart/form-data**，其他的格式可以自己理解。\n\n下面给各位吃瓜群众介绍上述三种格式在 **GET** 和 **POST** 两种请求方法中的区别，为了更直观的看到我们的数据的组织方式，我使用了 **Charles** 来进行抓包分析。  \n<!--more-->   \n我们测试的业务需求为：\n\n1. 客户端发起登录请求，服务器进行响应，请求的数据为 **user** 字段值为 **admin**； **pass** 字段值为 **123456**；\n2. 客户端上传一张图片到服务器，字段名为 **imageFile**，内容为图片的二进制数据。\n\n为了更好的测试，我对 Web 的请求基于 AFNetworking 2.5.0 版本做了一层简单的封装，发起请求的代码：\n\n```\n- (void)webRequest\n{\n    NSDictionary *bParams = @{ @\"user\" : @\"admin\",\n                               @\"pass\" : @\"123456\"};\n    \n    NSDictionary *params = @{ kWebServiceMethod     : @\"POST\",\n                              kWebServiceParams     : bParams,\n                              kWebServiceIdentifier : kPlatformAccountService,\n                              kWebServiceApiUrl     : @\"login\"};\n    \n    [CMLWebProxyService webRequestWithParam:params completionHandler:^(NSURLResponse *response, id responseObject, NSError *error) {\n        DDLogInfo(@\"responseObject:%@\", responseObject);\n    }];\n}\n\n```\n\n用来指定数据格式的代码封装在了叫 BaseService 的类中，方法如下：\n\n```\n- (NSString *)apiContentType\n{\n    return @\"application/x-www-form-urlencoded\";\n}\n```\n\nWeb 请求的封装的代码（基于 AFNetworking 2.5.0 版本）\n\n```\n+ (NSURLSessionDataTask *)webRequestWithParam:(NSDictionary *) params completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error)) completionHandler\n{\n    id<CMLService> service = [[CMLServiceFactory sharedInstance] serviceWithIdentifier:params[kWebServiceIdentifier]];\n    NSString *urlString = [NSString stringWithFormat:@\"%@%@/%@\", service.apiBaseUrl, service.apiVersion, params[kWebServiceApiUrl]];\n    AFHTTPRequestSerializer *requestSerializer = nil;\n    \n    if ( [service.apiContentType isEqualToString:@\"application/x-www-form-urlencoded\"] ) {\n        \n        requestSerializer = [AFHTTPRequestSerializer serializer];\n        \n    } else if ( [service.apiContentType isEqualToString:@\"application/json\"] ) {\n        \n        requestSerializer = [AFJSONRequestSerializer serializer];\n    }\n    \n    [requestSerializer setValue:@\"application/json\" forHTTPHeaderField:@\"Accept\"];\n    requestSerializer.timeoutInterval = kWebServiceTimeoutInterval;\n    \n    NSDictionary *headParams = params[kWebServiceHeadParams];\n    [headParams enumerateKeysAndObjectsUsingBlock:^(id  _Nonnull key, id  _Nonnull obj, BOOL * _Nonnull stop) {\n        [requestSerializer setValue:obj forHTTPHeaderField:key];\n    }];\n    \n    NSURLRequest *request = nil;·\n    NSArray *binParams = params[kWebServiceBinParams];\n    if ( binParams != nil && binParams.count != 0 ) {\n        request = [requestSerializer multipartFormRequestWithMethod:params[kWebServiceMethod]\n                                                          URLString:urlString\n                                                         parameters:params[kWebServiceParams]\n                                          constructingBodyWithBlock:^(id<AFMultipartFormData> formData) {\n                                              \n                                              for ( NSDictionary *binData in binParams ) {\n                                                  [formData appendPartWithFileData:binData[kWebBinData]\n                                                                              name:binData[kWebBinName]\n                                                                          fileName:binData[kWebBinFileName]\n                                                                          mimeType:binData[kWebBinMimeType]];\n                                              }\n                                              \n                                          } error:nil];\n    } else {\n        request = [requestSerializer requestWithMethod:params[kWebServiceMethod] URLString:urlString parameters:params[kWebServiceParams] error:nil];\n    }\n    \n    NSURLSessionDataTask *dataTsk = [[CMLWebProxyService sessionManager] dataTaskWithRequest:request completionHandler:completionHandler];\n    \n    [dataTsk resume];\n    \n    return dataTsk;\n}\n\n```\n\n### POST 下的数据组织形式\n\n先看看各个格式的抓包的截图，在做对比分析。\n\n**application/x-www-form-urlencoded** 格式的抓包截图\n\n![url 编码格式](/uploads/http_content_type_1.png)\n\n**application/json** 格式的抓包截图\n\n![url 编码格式](/uploads/http_content_type_2.png)\n\n**multipart/form-data** 格式的请求代码以及抓包的截图：\n\n```\n\tNSDictionary *bParams = @{ @\"user\" : @\"admin\",\n                               @\"pass\" : @\"123456\"};\n    \n    NSData *imageBin = UIImagePNGRepresentation([UIImage imageNamed:@\"avatar_cat\"]);\n    \n    NSDictionary *binPar = @{ kWebBinData : imageBin,\n                              kWebBinName : @\"imageFile\",\n                              kWebBinFileName : @\"image.png\",\n                              kWebBinMimeType : @\"image/png\"\n                             };\n    \n    NSDictionary *params = @{ kWebServiceMethod     : @\"POST\",\n                              kWebServiceParams     : bParams,\n                              kWebServiceBinParams  : @[binPar],\n                              kWebServiceIdentifier : kPlatformAccountService,\n                              kWebServiceApiUrl     : @\"login\"};\n                              \n```\n\n![url 编码格式](/uploads/http_content_type_3.png)\n\n**application/x-www-form-urlencoded** 格式对请求参数进行了 [**URL 编码**](http://deyimsf.iteye.com/blog/1776082) 并将参数放在了 **BODY** 中；**application/json** 格式是将参数进行了 [**JSON**](http://www.w3school.com.cn/json/json_syntax.asp) 格式的转换，放在了 **BODY** 中；\n\n前两种都是传的普通的文本数据，如果我们需要同时传输文本数据以及二进制数据时，就得用到 **multipart/form-data** 编码格式了，可以从图中看到在 **HTTP** 的头部的 **Content-Type** 中多了 **Boundary** 字段，该字段的作用为对多项数据进行分割；截图中 3 个参数都使用了指定的字符串进行了分割，在图片的那一项中也包含了 **Content-Type** 字段用来描述该项的数据格式为 **PNG** 图片。如果没有图片参数的话，也可以直接使用 **multipart/form-data** 格式来进行组织。\n\n> 用来分割的字符串的值是每次随机生成的。不同的客户生成的字符串长度也会不一样。\n\n### GET 下的数据组织形式\n\n**HTTP** 的 **GET** 请求方式，是将我们要请求的参数放在 **URL** 地址后面，所以 **GET** 方式只支持 **application/x-www-form-urlencoded** 格式，而 **application/json** 和 **multipart/form-data** 不支持的，这个应该比较容易理解。下面是我抓包的截图：\n\n![url 编码格式](/uploads/http_content_type_4.png)\n\n### 总结\n\n其实抓包截图做对比就很容易理解不同的参数的意义了，在很多情况下后端和前端开发人员都是使用成熟的第三方框架来帮我们做这部分工作，对 **HTTP** 协议了解的还不够细致，有时候发现在调试接口无法解析数据，其实很有可能 **Content-Type** 类型不一致导致的。如果觉得文本协议不够精简，也可以使用二进制协议来传输 **user** 和 **pass** 字段，比如 **protobuf** ，只要和服务器端协商好就可以。","source":"_posts/http-Content-Type.md","raw":"title: HTTP 之 Content-Type\ndate: 2016-08-29 20:27:25\ncategories: [开发笔记]\ntags: [HTTP]\n---\n\n在移动端开发中 HTTP 协议经常被用到，但是在面试或者工作中问到客户端和服务器传输业务数据，使用的数据的封装格式是什么以及怎么被封装到 HTTP 协议中时，很少有人能讲明白。\n\n在移动开发中 HTTP 协议为客户端到服务器端，提供了一条数据通道，能够将我们的业务数据传输到服务器，并且从服务器上获取响应数据。在 HTTP 协议头中的 **Content-Type** 字段描述了 **HTTP** 的 **BODY** 体的数据格式，而在 **BODY** 中可以定义我们业务数据的数据格式。**Content-Type** 字段可以用很多种类型，具体有哪些可以看 [**这里**](http://tool.oschina.net/commons)，并且也可以根据自身业务来自定义，不过这种做法比较少。这次我主要讲解三种格式分别为 **application/x-www-form-urlencoded**、**application/json** 以及 **multipart/form-data**，其他的格式可以自己理解。\n\n下面给各位吃瓜群众介绍上述三种格式在 **GET** 和 **POST** 两种请求方法中的区别，为了更直观的看到我们的数据的组织方式，我使用了 **Charles** 来进行抓包分析。  \n<!--more-->   \n我们测试的业务需求为：\n\n1. 客户端发起登录请求，服务器进行响应，请求的数据为 **user** 字段值为 **admin**； **pass** 字段值为 **123456**；\n2. 客户端上传一张图片到服务器，字段名为 **imageFile**，内容为图片的二进制数据。\n\n为了更好的测试，我对 Web 的请求基于 AFNetworking 2.5.0 版本做了一层简单的封装，发起请求的代码：\n\n```\n- (void)webRequest\n{\n    NSDictionary *bParams = @{ @\"user\" : @\"admin\",\n                               @\"pass\" : @\"123456\"};\n    \n    NSDictionary *params = @{ kWebServiceMethod     : @\"POST\",\n                              kWebServiceParams     : bParams,\n                              kWebServiceIdentifier : kPlatformAccountService,\n                              kWebServiceApiUrl     : @\"login\"};\n    \n    [CMLWebProxyService webRequestWithParam:params completionHandler:^(NSURLResponse *response, id responseObject, NSError *error) {\n        DDLogInfo(@\"responseObject:%@\", responseObject);\n    }];\n}\n\n```\n\n用来指定数据格式的代码封装在了叫 BaseService 的类中，方法如下：\n\n```\n- (NSString *)apiContentType\n{\n    return @\"application/x-www-form-urlencoded\";\n}\n```\n\nWeb 请求的封装的代码（基于 AFNetworking 2.5.0 版本）\n\n```\n+ (NSURLSessionDataTask *)webRequestWithParam:(NSDictionary *) params completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error)) completionHandler\n{\n    id<CMLService> service = [[CMLServiceFactory sharedInstance] serviceWithIdentifier:params[kWebServiceIdentifier]];\n    NSString *urlString = [NSString stringWithFormat:@\"%@%@/%@\", service.apiBaseUrl, service.apiVersion, params[kWebServiceApiUrl]];\n    AFHTTPRequestSerializer *requestSerializer = nil;\n    \n    if ( [service.apiContentType isEqualToString:@\"application/x-www-form-urlencoded\"] ) {\n        \n        requestSerializer = [AFHTTPRequestSerializer serializer];\n        \n    } else if ( [service.apiContentType isEqualToString:@\"application/json\"] ) {\n        \n        requestSerializer = [AFJSONRequestSerializer serializer];\n    }\n    \n    [requestSerializer setValue:@\"application/json\" forHTTPHeaderField:@\"Accept\"];\n    requestSerializer.timeoutInterval = kWebServiceTimeoutInterval;\n    \n    NSDictionary *headParams = params[kWebServiceHeadParams];\n    [headParams enumerateKeysAndObjectsUsingBlock:^(id  _Nonnull key, id  _Nonnull obj, BOOL * _Nonnull stop) {\n        [requestSerializer setValue:obj forHTTPHeaderField:key];\n    }];\n    \n    NSURLRequest *request = nil;·\n    NSArray *binParams = params[kWebServiceBinParams];\n    if ( binParams != nil && binParams.count != 0 ) {\n        request = [requestSerializer multipartFormRequestWithMethod:params[kWebServiceMethod]\n                                                          URLString:urlString\n                                                         parameters:params[kWebServiceParams]\n                                          constructingBodyWithBlock:^(id<AFMultipartFormData> formData) {\n                                              \n                                              for ( NSDictionary *binData in binParams ) {\n                                                  [formData appendPartWithFileData:binData[kWebBinData]\n                                                                              name:binData[kWebBinName]\n                                                                          fileName:binData[kWebBinFileName]\n                                                                          mimeType:binData[kWebBinMimeType]];\n                                              }\n                                              \n                                          } error:nil];\n    } else {\n        request = [requestSerializer requestWithMethod:params[kWebServiceMethod] URLString:urlString parameters:params[kWebServiceParams] error:nil];\n    }\n    \n    NSURLSessionDataTask *dataTsk = [[CMLWebProxyService sessionManager] dataTaskWithRequest:request completionHandler:completionHandler];\n    \n    [dataTsk resume];\n    \n    return dataTsk;\n}\n\n```\n\n### POST 下的数据组织形式\n\n先看看各个格式的抓包的截图，在做对比分析。\n\n**application/x-www-form-urlencoded** 格式的抓包截图\n\n![url 编码格式](/uploads/http_content_type_1.png)\n\n**application/json** 格式的抓包截图\n\n![url 编码格式](/uploads/http_content_type_2.png)\n\n**multipart/form-data** 格式的请求代码以及抓包的截图：\n\n```\n\tNSDictionary *bParams = @{ @\"user\" : @\"admin\",\n                               @\"pass\" : @\"123456\"};\n    \n    NSData *imageBin = UIImagePNGRepresentation([UIImage imageNamed:@\"avatar_cat\"]);\n    \n    NSDictionary *binPar = @{ kWebBinData : imageBin,\n                              kWebBinName : @\"imageFile\",\n                              kWebBinFileName : @\"image.png\",\n                              kWebBinMimeType : @\"image/png\"\n                             };\n    \n    NSDictionary *params = @{ kWebServiceMethod     : @\"POST\",\n                              kWebServiceParams     : bParams,\n                              kWebServiceBinParams  : @[binPar],\n                              kWebServiceIdentifier : kPlatformAccountService,\n                              kWebServiceApiUrl     : @\"login\"};\n                              \n```\n\n![url 编码格式](/uploads/http_content_type_3.png)\n\n**application/x-www-form-urlencoded** 格式对请求参数进行了 [**URL 编码**](http://deyimsf.iteye.com/blog/1776082) 并将参数放在了 **BODY** 中；**application/json** 格式是将参数进行了 [**JSON**](http://www.w3school.com.cn/json/json_syntax.asp) 格式的转换，放在了 **BODY** 中；\n\n前两种都是传的普通的文本数据，如果我们需要同时传输文本数据以及二进制数据时，就得用到 **multipart/form-data** 编码格式了，可以从图中看到在 **HTTP** 的头部的 **Content-Type** 中多了 **Boundary** 字段，该字段的作用为对多项数据进行分割；截图中 3 个参数都使用了指定的字符串进行了分割，在图片的那一项中也包含了 **Content-Type** 字段用来描述该项的数据格式为 **PNG** 图片。如果没有图片参数的话，也可以直接使用 **multipart/form-data** 格式来进行组织。\n\n> 用来分割的字符串的值是每次随机生成的。不同的客户生成的字符串长度也会不一样。\n\n### GET 下的数据组织形式\n\n**HTTP** 的 **GET** 请求方式，是将我们要请求的参数放在 **URL** 地址后面，所以 **GET** 方式只支持 **application/x-www-form-urlencoded** 格式，而 **application/json** 和 **multipart/form-data** 不支持的，这个应该比较容易理解。下面是我抓包的截图：\n\n![url 编码格式](/uploads/http_content_type_4.png)\n\n### 总结\n\n其实抓包截图做对比就很容易理解不同的参数的意义了，在很多情况下后端和前端开发人员都是使用成熟的第三方框架来帮我们做这部分工作，对 **HTTP** 协议了解的还不够细致，有时候发现在调试接口无法解析数据，其实很有可能 **Content-Type** 类型不一致导致的。如果觉得文本协议不够精简，也可以使用二进制协议来传输 **user** 和 **pass** 字段，比如 **protobuf** ，只要和服务器端协商好就可以。","slug":"http-Content-Type","published":1,"updated":"2016-08-29T12:37:38.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj1a0t08m0015gdp1974wq7y1","sticky":0},{"title":"常用的Git命令","date":"2016-04-14T01:19:04.000Z","_content":"\n1年多以前从SVN阵营转向Git，SVN用的最多就是图行化工具，刚转到Git时也是喜欢用图形化工具和XCode自带Git管理工具的，但是在使用XCode自带Git管理工具出过几次问题后，逐渐转向使用命令。现在基本上是使用`SourceTree`来做一些浏览性的工作比如commit改动、分支走向等，其他的基本上使用命令来操作。Git的好我就不多说，先看下面一张图了解一下Git的一些名词，在看看常用的Git命令。\n\n### Git图解\n\n![](/uploads/gitframe.png)\n\n* **Workspace**：工作区\n* **Index / Stage**：暂存区\n* **Repository**：仓库区（或本地仓库）\n* **Remote**：远程仓库\n\n<!--more--> \n\n### 新建代码库\n\n```\n# 在当前目录新建一个Git代码库\n$ git init\n\n# 新建一个目录，将其初始化为Git代码库\n$ git init [project-name]\n\n# 下载一个项目和它的整个代码历史\n$ git clone [url]\n```\n\n### 基本配置\n\nGit的设置文件为`.gitconfig`，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。\n\n```\n# 显示当前的Git配置\n$ git config --list\n\n# 编辑Git配置文件\n$ git config -e [--global]\n\n# 设置提交代码时的用户信息\n$ git config [--global] user.name \"[name]\"\n$ git config [--global] user.email \"[email address]\"\n```\n\n### 增加/删除文件\n\n```\n# 添加指定文件到暂存区\n$ git add [file1] [file2] ...\n\n# 添加指定目录到暂存区，包括子目录\n$ git add [dir]\n\n# 添加当前目录的所有文件到暂存区\n$ git add .\n\n# 删除工作区文件，并且将这次删除放入暂存区\n$ git rm [file1] [file2] ...\n\n# 停止追踪指定文件，但该文件会保留在工作区\n$ git rm --cached [file]\n\n# 改名文件，并且将这个改名放入暂存区\n$ git mv [file-original] [file-renamed]\n```\n\n### 代码提交\n\n```\n# 提交暂存区到仓库区\n$ git commit -m [message]\n\n# 提交暂存区的指定文件到仓库区\n$ git commit [file1] [file2] ... -m [message]\n\n# 提交工作区自上次commit之后的变化，直接到仓库区\n$ git commit -a\n\n# 提交时显示所有diff信息\n$ git commit -v\n\n# 使用一次新的commit，替代上一次提交\n# 如果代码没有任何新变化，则用来改写上一次commit的提交信息\n$ git commit --amend -m [message]\n\n# 重做上一次commit，并包括指定文件的新变化\n$ git commit --amend [file1] [file2] ...\n```\n\n### 暂存区  \n\n```\n# 将工作区内容转存到暂存区\n$ git stash\n\n# 列所有stash\n$ git stash list\n\n# 删除暂存区\n$ git stash drop\n\n# 将暂存区内容放到工作区\n$ git stash apply\n```\n\n### 分支操作\n\n```\n# 列出所有本地分支\n$ git branch\n\n# 列出所有远程分支\n$ git branch -r\n\n# 列出所有本地分支和远程分支\n$ git branch -a\n\n# 新建一个分支，但依然停留在当前分支\n$ git branch [branch-name]\n\n# 新建一个分支，并切换到该分支\n$ git checkout -b [branch]\n\n# 重远程仓库新建一个分支，并切换到该分支\n$ git checkout -b [branch-name] origin/[branch]\n\n# 新建一个分支，指向指定commit\n$ git branch [branch] [commit]\n\n# 新建一个分支，与指定的远程分支建立追踪关系\n$ git branch --track [branch] [remote-branch]\n\n# 切换到指定分支，并更新工作区\n$ git checkout [branch-name]\n\n# 建立追踪关系，在现有分支与指定的远程分支之间\n$ git branch --set-upstream [branch] [remote-branch]\n\n# 合并指定分支到当前分支（快进式合并）\n$ git merge [branch]\n\n# 合并指定分支，并将当前操作当成一次commit（会在分支上生成一个新节点）\n$ git merge --no-ff [branch]\n\n# 查看已经被合并到当前分支的分支\n$ git branch --merged\n\n# 查看尚未被合并到当前分支的分支\n$ git br --no-merged\n\n# 合并指定分支到当前分支，同时删除分支\n$ git rebase [branch]\n\n# 选择一个commit，合并进当前分支\n$ git cherry-pick [commit]\n\n# 删除分支\n$ git branch -d [branch-name]\n\n# 删除远程分支\n$ git push origin --delete [branch-name]\n$ git branch -dr [remote/branch]\n\n# 删除不存在对应远程分支的本地分支\n$ git remote show origin\n$ git remote prune origin\n\n# 更简单的方法是使用这个命令，它在fetch之后删除掉没有与远程分支对应的本地分支\n$ git fetch -p\n```\n\n### 标签\n\n```\n# 列出所有tag\n$ git tag\n\n# 新建一个tag在当前commit\n$ git tag [tag]\n\n# 新建一个tag在指定commit\n$ git tag [tag] [commit]\n\n# 查看tag信息\n$ git show [tag]\n\n# 提交指定tag\n$ git push [remote] [tag]\n\n# 提交所有tag\n$ git push [remote] --tags\n\n# 新建一个分支，指向某个tag\n$ git checkout -b [branch] [tag]\n```\n\n### 查看信息\n\n```\n# 显示有变更的文件\n$ git status\n\n# 显示当前分支的版本历史\n$ git log\n\n# 显示commit历史，以及每次commit发生变更的文件\n$ git log --stat\n\n# 显示某个文件的版本历史，包括文件改名\n$ git log --follow [file]\n$ git whatchanged [file]\n\n# 显示指定文件相关的每一次diff\n$ git log -p [file]\n\n# 显示指定文件是什么人在什么时间修改过\n$ git blame [file]\n\n# 显示暂存区和工作区的差异\n$ git diff\n\n# 显示暂存区和上一个commit的差异\n$ git diff --cached [file]\n\n# 显示工作区与当前分支最新commit之间的差异\n$ git diff HEAD\n\n# 显示两次提交之间的差异\n$ git diff [first-branch]...[second-branch]\n\n# 显示某次提交的元数据和内容变化\n$ git show [commit]\n\n# 显示某次提交发生变化的文件\n$ git show --name-only [commit]\n\n# 显示某次提交时，某个文件的内容\n$ git show [commit]:[filename]\n\n# 显示当前分支的最近几次提交（如果没有push到远程，就执行了reset，那这个绝对是救命用的了）\n$ git reflog\n```\n\n### 远程同步\n\n```\n# 下载远程仓库的所有变动\n$ git fetch [remote]\n\n# 显示所有远程仓库\n$ git remote -v\n\n# 显示某个远程仓库的信息\n$ git remote show [remote]\n\n# 增加一个新的远程仓库，并命名\n$ git remote add [shortname] [url]\n\n# 取回远程仓库的变化，并与本地分支合并\n$ git pull [remote] [branch]\n\n# 上传本地指定分支到远程仓库\n$ git push [remote] [branch]\n\n# 强行推送当前分支到远程仓库，即使有冲突\n$ git push [remote] --force\n\n# 推送所有分支到远程仓库\n$ git push [remote] --all\n```\n\n### 撤销\n\n```\n# 恢复暂存区的指定文件到工作区\n$ git checkout [file]\n\n# 恢复某个commit的指定文件到工作区\n$ git checkout [commit] [file]\n\n# 恢复上一个commit的所有文件到工作区\n$ git checkout .\n\n# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变\n$ git reset [file]\n\n# 重置暂存区与工作区，与上一次commit保持一致\n$ git reset --hard\n\n# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变\n$ git reset [commit]\n\n# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致\n$ git reset --hard [commit]\n\n# 重置当前HEAD为指定commit，但保持暂存区和工作区不变\n$ git reset --keep [commit]\n\n# 新建一个commit，用来撤销指定commit\n# 后者的所有变化都将被前者抵消，并且应用到当前分支\n$ git revert [commit]\n```\n\n### 其他\n\n```\n# 生成一个可供发布的压缩包\n$ git archive\n```","source":"_posts/git-basic-commands.md","raw":"title: 常用的Git命令\ndate: 2016-04-14 09:19:04\ncategories: [知识整理/总结]\ntags: [Git]\n---\n\n1年多以前从SVN阵营转向Git，SVN用的最多就是图行化工具，刚转到Git时也是喜欢用图形化工具和XCode自带Git管理工具的，但是在使用XCode自带Git管理工具出过几次问题后，逐渐转向使用命令。现在基本上是使用`SourceTree`来做一些浏览性的工作比如commit改动、分支走向等，其他的基本上使用命令来操作。Git的好我就不多说，先看下面一张图了解一下Git的一些名词，在看看常用的Git命令。\n\n### Git图解\n\n![](/uploads/gitframe.png)\n\n* **Workspace**：工作区\n* **Index / Stage**：暂存区\n* **Repository**：仓库区（或本地仓库）\n* **Remote**：远程仓库\n\n<!--more--> \n\n### 新建代码库\n\n```\n# 在当前目录新建一个Git代码库\n$ git init\n\n# 新建一个目录，将其初始化为Git代码库\n$ git init [project-name]\n\n# 下载一个项目和它的整个代码历史\n$ git clone [url]\n```\n\n### 基本配置\n\nGit的设置文件为`.gitconfig`，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。\n\n```\n# 显示当前的Git配置\n$ git config --list\n\n# 编辑Git配置文件\n$ git config -e [--global]\n\n# 设置提交代码时的用户信息\n$ git config [--global] user.name \"[name]\"\n$ git config [--global] user.email \"[email address]\"\n```\n\n### 增加/删除文件\n\n```\n# 添加指定文件到暂存区\n$ git add [file1] [file2] ...\n\n# 添加指定目录到暂存区，包括子目录\n$ git add [dir]\n\n# 添加当前目录的所有文件到暂存区\n$ git add .\n\n# 删除工作区文件，并且将这次删除放入暂存区\n$ git rm [file1] [file2] ...\n\n# 停止追踪指定文件，但该文件会保留在工作区\n$ git rm --cached [file]\n\n# 改名文件，并且将这个改名放入暂存区\n$ git mv [file-original] [file-renamed]\n```\n\n### 代码提交\n\n```\n# 提交暂存区到仓库区\n$ git commit -m [message]\n\n# 提交暂存区的指定文件到仓库区\n$ git commit [file1] [file2] ... -m [message]\n\n# 提交工作区自上次commit之后的变化，直接到仓库区\n$ git commit -a\n\n# 提交时显示所有diff信息\n$ git commit -v\n\n# 使用一次新的commit，替代上一次提交\n# 如果代码没有任何新变化，则用来改写上一次commit的提交信息\n$ git commit --amend -m [message]\n\n# 重做上一次commit，并包括指定文件的新变化\n$ git commit --amend [file1] [file2] ...\n```\n\n### 暂存区  \n\n```\n# 将工作区内容转存到暂存区\n$ git stash\n\n# 列所有stash\n$ git stash list\n\n# 删除暂存区\n$ git stash drop\n\n# 将暂存区内容放到工作区\n$ git stash apply\n```\n\n### 分支操作\n\n```\n# 列出所有本地分支\n$ git branch\n\n# 列出所有远程分支\n$ git branch -r\n\n# 列出所有本地分支和远程分支\n$ git branch -a\n\n# 新建一个分支，但依然停留在当前分支\n$ git branch [branch-name]\n\n# 新建一个分支，并切换到该分支\n$ git checkout -b [branch]\n\n# 重远程仓库新建一个分支，并切换到该分支\n$ git checkout -b [branch-name] origin/[branch]\n\n# 新建一个分支，指向指定commit\n$ git branch [branch] [commit]\n\n# 新建一个分支，与指定的远程分支建立追踪关系\n$ git branch --track [branch] [remote-branch]\n\n# 切换到指定分支，并更新工作区\n$ git checkout [branch-name]\n\n# 建立追踪关系，在现有分支与指定的远程分支之间\n$ git branch --set-upstream [branch] [remote-branch]\n\n# 合并指定分支到当前分支（快进式合并）\n$ git merge [branch]\n\n# 合并指定分支，并将当前操作当成一次commit（会在分支上生成一个新节点）\n$ git merge --no-ff [branch]\n\n# 查看已经被合并到当前分支的分支\n$ git branch --merged\n\n# 查看尚未被合并到当前分支的分支\n$ git br --no-merged\n\n# 合并指定分支到当前分支，同时删除分支\n$ git rebase [branch]\n\n# 选择一个commit，合并进当前分支\n$ git cherry-pick [commit]\n\n# 删除分支\n$ git branch -d [branch-name]\n\n# 删除远程分支\n$ git push origin --delete [branch-name]\n$ git branch -dr [remote/branch]\n\n# 删除不存在对应远程分支的本地分支\n$ git remote show origin\n$ git remote prune origin\n\n# 更简单的方法是使用这个命令，它在fetch之后删除掉没有与远程分支对应的本地分支\n$ git fetch -p\n```\n\n### 标签\n\n```\n# 列出所有tag\n$ git tag\n\n# 新建一个tag在当前commit\n$ git tag [tag]\n\n# 新建一个tag在指定commit\n$ git tag [tag] [commit]\n\n# 查看tag信息\n$ git show [tag]\n\n# 提交指定tag\n$ git push [remote] [tag]\n\n# 提交所有tag\n$ git push [remote] --tags\n\n# 新建一个分支，指向某个tag\n$ git checkout -b [branch] [tag]\n```\n\n### 查看信息\n\n```\n# 显示有变更的文件\n$ git status\n\n# 显示当前分支的版本历史\n$ git log\n\n# 显示commit历史，以及每次commit发生变更的文件\n$ git log --stat\n\n# 显示某个文件的版本历史，包括文件改名\n$ git log --follow [file]\n$ git whatchanged [file]\n\n# 显示指定文件相关的每一次diff\n$ git log -p [file]\n\n# 显示指定文件是什么人在什么时间修改过\n$ git blame [file]\n\n# 显示暂存区和工作区的差异\n$ git diff\n\n# 显示暂存区和上一个commit的差异\n$ git diff --cached [file]\n\n# 显示工作区与当前分支最新commit之间的差异\n$ git diff HEAD\n\n# 显示两次提交之间的差异\n$ git diff [first-branch]...[second-branch]\n\n# 显示某次提交的元数据和内容变化\n$ git show [commit]\n\n# 显示某次提交发生变化的文件\n$ git show --name-only [commit]\n\n# 显示某次提交时，某个文件的内容\n$ git show [commit]:[filename]\n\n# 显示当前分支的最近几次提交（如果没有push到远程，就执行了reset，那这个绝对是救命用的了）\n$ git reflog\n```\n\n### 远程同步\n\n```\n# 下载远程仓库的所有变动\n$ git fetch [remote]\n\n# 显示所有远程仓库\n$ git remote -v\n\n# 显示某个远程仓库的信息\n$ git remote show [remote]\n\n# 增加一个新的远程仓库，并命名\n$ git remote add [shortname] [url]\n\n# 取回远程仓库的变化，并与本地分支合并\n$ git pull [remote] [branch]\n\n# 上传本地指定分支到远程仓库\n$ git push [remote] [branch]\n\n# 强行推送当前分支到远程仓库，即使有冲突\n$ git push [remote] --force\n\n# 推送所有分支到远程仓库\n$ git push [remote] --all\n```\n\n### 撤销\n\n```\n# 恢复暂存区的指定文件到工作区\n$ git checkout [file]\n\n# 恢复某个commit的指定文件到工作区\n$ git checkout [commit] [file]\n\n# 恢复上一个commit的所有文件到工作区\n$ git checkout .\n\n# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变\n$ git reset [file]\n\n# 重置暂存区与工作区，与上一次commit保持一致\n$ git reset --hard\n\n# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变\n$ git reset [commit]\n\n# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致\n$ git reset --hard [commit]\n\n# 重置当前HEAD为指定commit，但保持暂存区和工作区不变\n$ git reset --keep [commit]\n\n# 新建一个commit，用来撤销指定commit\n# 后者的所有变化都将被前者抵消，并且应用到当前分支\n$ git revert [commit]\n```\n\n### 其他\n\n```\n# 生成一个可供发布的压缩包\n$ git archive\n```","slug":"git-basic-commands","published":1,"updated":"2016-04-14T04:51:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj1a0t08p0019gdp12j55z1qb","sticky":0},{"title":"数字证书的基础知识","date":"2016-02-26T12:38:53.000Z","_content":"\n> 在之前的[《iOS开发者证书以及代码签名学习笔记》](http://www.enkichen.com/2016/01/15/ios-certification-and-code-sign-note/)博文中介绍了iOS开发证书以及代码签名相关的知识点，为了更好理解其中证书的特性，这里对数字证书以及相关的知识进行了整理和总结。\n\n在讲数字证书之前必须要讲**非对称加密算法**和**摘要算法**，因为数字证书的基础就是各种加解密算法（非对称加密、摘要算法），而其中的核心就是非对称加密算法了。目前而言加密方法可以分为两大类。一类是**单钥加密**（private key cryptography）也可以称为对称加密，还有一类叫做**双钥加密**（public key cryptography）也可称为非对称加密。前者的加密和解密过程都用同一套密码，后者的加密和解密过程用的是不同的密码。下面来看看对称加密、非对称加密以及摘要算法，他们是怎样应用在数字证书中的。  \n<!--more-->\n### 对称加密\n对称加密(也叫私钥加密)指加密和解密使用相同密钥的加密算法。有时又叫传统密码算法，就是加密密钥能够从解密密钥中推算出来，同时解密密钥也可以从加密密钥中推算出来。而在大多数的对称算法中，加密密钥和解密密钥是相同的，所以也称这种加密算法为秘密密钥算法或单密钥算法。\n\n在应用该算法时，它要求发送方和接收方在安全通信之前，商定一个密钥。对称算法的安全性依赖于密钥，泄漏密钥就意味着任何人都可以对他们发送或接收的消息解密，所以密钥的保密性对通信性至关重要。对称加密算法的特点是算法公开、计算量小、加密速度快、加密效率高。对称加密有很多种算法，由于它效率很高，所以被广泛使用在很多加密协议的核心当中。不足之处是，交易双方都使用同样钥匙，安全性得不到保证。\n\n#### 常见的对称加密算法\n\n* **DES**：数据加密标准（DES，Data Encryption Standard）是一种使用密钥加密的块密码，它基于使用**56位密钥**的对称算法，这个算法因为包含一些机密设计元素，相对短的密钥长度以及被怀疑内含美国国家安全局（NSA）的后门而在开始时是有争议的，DES现在已经不被视为一种安全的加密算法，主要因为它使用的56位密钥过短，导致容易被破解。为了提供实用所需的安全性，可以使用DES的派生算法3DES来进行加密，虽然3DES也存在理论上的攻击方法。\n\n* **AES**：高级加密标准（英语：Advanced Encryption Standard，缩写：AES），这个标准用来替代原先的DES，已经被多方分析且广为全世界所使用，2006年，高级加密标准已然成为对称密钥加密中最流行的算法之一。AES的区块长度固定为128比特，**密钥长度则可以是128，192或256比特**。\n\n* **RC4**：RC4加密算法是大名鼎鼎的RSA三人组中的头号人物Ronald Rivest在1987年设计的密钥长度可变的流加密算法簇。该算法的速度可以达到DES加密的10倍左右，且具有很高级别的非线性。RC4起初是用于保护商业机密的。但是在1994年9月，它的算法被发布在互联网上，也就不再有什么商业机密了。\n\n* **IDEA**：是旅居瑞士中国青年学者来学嘉和著名密码专家J.Massey于1990年提出的。它在1990年正式公布并在以后得到增强。这种算法是在DES算法的基础上发展出来的，类似于三重DES，和DES一样IDEA也是属于对称密钥算法。发展IDEA也是因为感到DES具有密钥太短等缺点，已经过时。**IDEA的密钥为128位**，这么长的密钥在今后若干年内应该是安全的。\n\n### 非对称加密\n\n与对称加密算法不同，非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）；并且加密密钥和解密密钥是成对出现的。非对称加密算法在加密和解密过程使用了不同的密钥，非对称加密也称为公钥加密，在密钥对中，其中一个密钥是对外公开的，所有人都可以获取到，称为公钥，其中一个密钥是不公开的称为私钥。\n\n#### 非对称加密的特性\n\n* 对于一个公钥，有且只有一个对应的私钥。\n* 公钥是公开的，并且不能通过公钥反推出私钥。\n* 通过私钥加密的密文只能通过公钥能解密，通过公钥加密的密文也只能通过私钥能解密。\n\n> 通过公钥是极难推算出私钥的，只能通过穷举，所以只要密钥足够长，要想从公钥推算出私钥几乎不可能的。\n\n#### 非对称加密的主要用途\n\n* **对信息保密，防止中间人攻击**：将明文使用公钥加密，传输给接收者，这样确保信息只能被有私钥的拥有者解密，其他人无法获得明文信息，因为没有私钥无法进行解密。该方法一般用于交换**`对称密钥`**。\n* **身份验证和防止信息篡改**：私钥拥有者使用私钥加密一段授权明文，并将授权明文和加密后的密文，以及公钥一并发送出来，接收方只需要通过公钥将密文解密后与授权明文对比是否一致，就可以判断明文在中途是否被篡改过。此方法用于**`数字签名`**。\n\n#### 常见的非对称加密算法\n\n* **RSA**：1977年，三位数学家Rivest、Shamir 和 Adleman 设计了一种算法，可以实现非对称加密。这种算法用他们三个人的名字命名，叫做RSA算法。从那时直到现在，RSA算法一直是最广为使用的\"非对称加密算法\"。毫不夸张地说，只要有计算机网络的地方，就有RSA算法。这种算法非常可靠，密钥越长，它就越难破解。根据已经披露的文献，目前被破解的最长RSA密钥是768个二进制位。也就是说，长度超过768位的密钥，还无法破解（至少没人公开宣布）。因此可以认为，**1024位的RSA密钥基本安全，2048位的密钥极其安全**。适用于数字签名和密钥交换。 该算法是目前应用最广泛的公钥加密算法，特别适用于通过 Internet 传送的数据。  \n\n* **DSA**：数字签名算法 (Digital Signature Algorithm, DSA) 由美国国家安全署 (United States National Security Agency, NSA) 发明，已作为数字签名的标准。在DSA数字签名和认证中，发送者使用自己的私钥对文件或消息进行签名，接受者收到消息后使用发送者的公钥来验证签名的真实性。DSA只是一种算法，和RSA不同之处在于它不能用作加密和解密，也不能进行密钥交换，只用于签名，它比RSA要快很多。DSA 算法的安全性取决于自计算离散算法的困难。这种算法，不适用于数据加密，仅适用于数字签名。  \n\n* **Diffie-Hellman**：一种确保共享KEY安全穿越不安全网络的方法。Whitefield与Martin Hellman在1976年提出了一个奇妙的密钥交换协议，称为Diffie-Hellman密钥交换协议/算法(Diffie-Hellman Key Exchange/Agreement Algorithm)。这个机制的巧妙在于需要安全通信的双方可以用这个方法确定对称密钥。然后可以用这个密钥进行加密和解密。但是注意，这个密钥交换协议/算法只能用于密钥的交换，而不能进行消息的加密和解密。双方确定要用的密钥后，要使用其他对称密钥操作加密算法实际加密和解密消息。该算法仅适用于密钥交换。\n* **ECC**：椭圆加密算法（ECC）是一种公钥加密体制，最初由Koblitz和Miller两人于1985年提出，与经典的RSA，DSA等公钥密码体制相比，椭圆密码体制有以下优点：160位的椭圆密钥与1024位的RSA密钥安全性相同；在私钥的加密解密速度上，ECC算法比RSA、DSA速度更快；存储空间占用小；带宽要求低；ECC算法的数学理论非常深奥和复杂，在工程应用中比较难于实现，但它的单位安全强度相对较高。\n\n非对称加密算法可能是世界上最重要的算法，它是当今电子商务等领域的基石。非对称加密算法如此强大可靠，却有一个弊端，就是加解密比较耗时。因此，在实际使用中，往往与对称加密和摘要算法结合使用。列如在实体之间交换对称密钥时，或者在签署一封邮件的散列时（数字签名）。\n\n> 散列是通过应用一种单向数学函数获得的一个定长结果，对于数据而言，叫做散列算法。\n\n### 摘要算法\n\n摘要算法是一个神奇的算法，也称为散列或者散列值。是一种与基于密钥（对称密钥或公钥）的加密不同的数据转换类型。散列就是通过把一个叫做散列算法的单向数学函数应用于数据，将任意长度的一块数据转换为一个定长的、不可逆转的数字，其长度通常在128～256位之间。所产生的散列值的长度应足够长，因此使找到两块具有相同散列值的数据的机会很少。\n\n#### 摘要算法具有以下特性：\n\n* 只要源文本不同，计算得到的结果，必然不同（或者说机会很少）。\n* 无法从结果反推出源数据（那是当然的，不然就能量不守恒了）。\n\n#### 常见的摘要算法：\n\n* **MD5**：是RSA数据安全公司开发的一种单向散列算法，MD5被广泛使用，可以用来把不同长度的数据块进行暗码运算成一个固定位位的数值（通常是128位）。\n* **SHA-1**：与 DSA 公钥算法相似，安全散列算法1（SHA-1）也是由 NSA 设计的，并由 NIST 将其收录到 FIPS 中，作为散列数据的标准。它可产生一个 160 位的散列值。SHA-1 是流行的用于创建数字签名的单向散列算法。\n* **MAC（Message Authentication Code）**：消息认证代码，是一种使用密钥的单向函数，可以用它们在系统上或用户之间认证文件或消息，常见的是HMAC（用于消息认证的密钥散列算法）。\n* **CRC（Cyclic Redundancy Check）**：循环冗余校验码，CRC校验由于实现简单，检错能力强，被广泛使用在各种数据校验应用中。占用系统资源少，用软硬件均能实现，是进行数据传输差错检测地一种很好的手段（CRC 并不是严格意义上的散列算法，但它的作用与散列算法大致相同，所以归于此类）。\n\n摘要算法用于对比信息源是否一致，因为只要源数据发生变化，得到的摘要必然不同。因为通常结果比源数据要短很多，所以称为“摘要”。\n\n应用场景，如发件人生成邮件的散列值并加密它，然后将它与邮件本身一起发送。而收件人同时解密邮件和散列值，并由接收到的邮件产生另外一个散列值，然后将两个散列值进行比较。如果两者相同，邮件极有可能在传输期间没有发生任何改变。\n\n### 数字签名\n\n数字签名就是对非对称加密和摘要算法的一种应用，能够确保信息在发布后不会被篡改（摘要算法特性），保证数据的完整性和可信性；同时也可以防止数据被他人伪造（非对称加密算法特性）；列如，我们有一段授权文本需要发布时，为了防止中途篡改发布的内容，保证发布文本的完整性，以及文本是由指定的发布者发布的。那么，可以通过摘要算法得到发布内容的摘要，得到摘要之后，发布者使用私钥加密得到密文（签名），这时候将源文本、密文（签名）以及公钥一起发布出去即可。  \n\n验证过程为：首先验证公钥是否是发布者的公钥，然后用公钥对密文进行解密，得到摘要，使用发布者对文本同样的摘要算法得到摘要文本，比对摘要是否一致即可确认信息是否被篡改或者是指定发布者发布的。\n\n![数字签名](/uploads/数字签名.jpg)\n\n数字签名可以快速验证文本的完整性和合法性，已广泛应用于各个领域。\n\n> 公钥的验证在后续数字证书的授权链中提到验证方法。\n\n### 数字证书\n\n#### 现实生活中的证书\n\n在现实生活中，证书顾名思义，就是权限机构颁发的证明。比如英语6级证书，就是教育部门颁发给通过了6级考核的个人的证明，证明这个人的英语能力。我们来看一下这个证书的组成：\n\n* 被证明人：老王\n* 内容：通过了英语六级\n* 盖章：教育部门的公章或钢印\n\n当老王用这张证书找工作时，用人单位会通过查看证书的各项内容（尤其是公章），来验证证书的合法性和老王的能力。在现实生活中经常有假的6级证书，这些假证书最重要的就是有一个假公章。现实生活中使用法律法规来约束私刻假公章的行为，但是用人单位可能不能十分准确的判断公章是真是假。而数字签字可以来解决该类问题。\n\n#### 数字证书\n\n数字证书就是通过数字签名实现的数字化的证书，在现实生活中公章可以被伪造，但是在计算数字世界中，数字签名是没办法被伪造的，比如上述证书中，在一个证书文件中写明了证书内容，颁发证书时，教育部门用他们的私钥对文件的摘要信息进行签名，将签名和证书文件一起发布，这样就能确保该证书无法被伪造。验证证书是否合法时，首先用教育部门的公钥（公钥是公开的谁都可以获取到）对签名进行解密得到一个摘要信息，使用教育部门同样的摘要算法得到证书的另一个摘要信息，对比两个摘要信息是否一致就能确定该证书是否合法。在一般的证书组成中部分中，还加入了一些其他信息，比如证书的有效期。\n\n数字证书也有很多的签发机构，不同的签发机构签发的证书，用途也是不一样的，比如iOS开发中，使用到的ipa文件签名证书，需要到苹果申请。而在Web访问中为了防止Web内容在网络中安全传输，需要用到的SSL证书则需要向几家公认的机构签发。这些签发机构统称为CA（Certificate Authority）。\n\nWeb访问相关的证书可以向国际公认的几个机构：\n\n1. [**WebTrust**](http://www.webtrust.net/)   \n2. [**GlobalSign**](http://cn.globalsign.com/)  \n3. [**GTE**](http://certificate.fyicenter.com/335_Root_CA_GTE_CyberTrust_Global_Root_GTE_CyberTrust_Solutions.html)\n4. [**Nortel**](http://www.nortel.com/)\n5. [**Verisign**](http://www.verisign.com/)\n\n#### 数字证书的验证\n\n申请证书是为了验证，比如Web应用相关的SSL证书验证方是浏览器，iOS各种证书的验证方是iOS设备。因为数字证书是基于数字签名的，所有数字证书的合法性验证就是验证数字证书的签名是否正确，对于签名的验证在是需要签发机构的公钥才能验证；\n\n对于iOS开发证书来说，申请完签名证书后，还需要安装苹果的公钥证书（XCode安装后会自动安装），这样才能确保我们申请的证书是可以被验证通过的（合法的），可用来进行ipa文件签名的。对于Web相关的证书签名的验证，则是由浏览器来验证，对于国际公认的几个证书签发机构浏览器会内置其公钥证书，用来验证数字证书的可信性。\n\n当数字证书通过验证后，便可以用数字证书做对应的事情，iOS开发证书可以用来对APP进行签名，SSL证书可以用来做Web内容加密处理相关的事情。所以有了这些证书之后，能保证在数据的传输过程中，数据是不会被篡改的，并且信息来源也是不能不修改的，从而确保信息安全。\n\n> 对于iOS，iOS系统已经将这个验证过程固化在系统中了，除非越狱，否则无法绕过\n\n#### 数字证书的授权链\n\n数字证书还包含一个授权链信息，举个例子：如果你要申请休假1周，需要你的上司审批，你的上司需要他的上司同意，最终需要大老板同意，那么这一层层的授权，形成了一个授权链，大老板是授权链的根(root)，中间这些环节分别是被更接近root的人授权的。  \n\n比如苹果开发者的APP签名证书，该证书可以用来对APP进行签名，该证书实际上是由苹果的Worldwide Developer Relations Certificate Authority（WDRCA）授权签名的，而它是由Apple Certificate Authority授权签名的。在这个关系链中苹果的CA是根。 苹果CA根证书默认是内置在苹果系统中的，所以WDRCA的可信性可以由苹果内置的CA根证书来验证其可信性。\n\nWeb相关的SSL证书顶部CA根，则就是上述提到的几家公认的签发机构，当我们需要Web做SSL的证书时，便可以向上述机构申请，通常向根机构申请费用都会比较高，也可以向一些二级授权机构进行申请，选择根机构证书签发的好处就是目前大多数的浏览器都会预装内置了这些权威CA的公钥证书，这样，在使用这些权威CA签发过的证书的时候，浏览器一般不会报风险提示。\n\n#### 总结\n数字证书签名的基础是非对称加密算法，利用了非对称加密的身份验证和防止信息篡改的特性来实现的，在一些其他方面比如HTTPS中密钥交换用的就是非对称加密的保密特性来实现的，在非对称加密算法中RSA应用最广。非对称加密虽好，但却有一个弊端，就是加解密比较耗时，所以一般都是配合对称加密一起使用。\n\n> 本文只是对数字证书做了概要的介绍，很多细节都未涉及到，如果各位对一些细节感兴趣可以根据本文涉及的知识点进入更深入的学习。同时本文也未涉及到数字证书的管理以及数字证书的格式等知识的介绍，这些内容将在后续文章中为大家整理和介绍。\n\n### 参考资料\n[RSA加密与破解](http://www.cnblogs.com/vamei/p/3480994.html)  \n[RSA算法原理](http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html)   \n[漫谈iOS程序的证书和签名机制](http://www.pchou.info/ios/2015/12/14/ios-certification-and-code-sign.html)","source":"_posts/digital-certificate-based.md","raw":"title: 数字证书的基础知识  \ndate: 2016-02-26 20:38:53\ncategories: [知识整理/总结]\ntags: [数字证书, 非对称加密, RSA, 摘要算法]\n---\n\n> 在之前的[《iOS开发者证书以及代码签名学习笔记》](http://www.enkichen.com/2016/01/15/ios-certification-and-code-sign-note/)博文中介绍了iOS开发证书以及代码签名相关的知识点，为了更好理解其中证书的特性，这里对数字证书以及相关的知识进行了整理和总结。\n\n在讲数字证书之前必须要讲**非对称加密算法**和**摘要算法**，因为数字证书的基础就是各种加解密算法（非对称加密、摘要算法），而其中的核心就是非对称加密算法了。目前而言加密方法可以分为两大类。一类是**单钥加密**（private key cryptography）也可以称为对称加密，还有一类叫做**双钥加密**（public key cryptography）也可称为非对称加密。前者的加密和解密过程都用同一套密码，后者的加密和解密过程用的是不同的密码。下面来看看对称加密、非对称加密以及摘要算法，他们是怎样应用在数字证书中的。  \n<!--more-->\n### 对称加密\n对称加密(也叫私钥加密)指加密和解密使用相同密钥的加密算法。有时又叫传统密码算法，就是加密密钥能够从解密密钥中推算出来，同时解密密钥也可以从加密密钥中推算出来。而在大多数的对称算法中，加密密钥和解密密钥是相同的，所以也称这种加密算法为秘密密钥算法或单密钥算法。\n\n在应用该算法时，它要求发送方和接收方在安全通信之前，商定一个密钥。对称算法的安全性依赖于密钥，泄漏密钥就意味着任何人都可以对他们发送或接收的消息解密，所以密钥的保密性对通信性至关重要。对称加密算法的特点是算法公开、计算量小、加密速度快、加密效率高。对称加密有很多种算法，由于它效率很高，所以被广泛使用在很多加密协议的核心当中。不足之处是，交易双方都使用同样钥匙，安全性得不到保证。\n\n#### 常见的对称加密算法\n\n* **DES**：数据加密标准（DES，Data Encryption Standard）是一种使用密钥加密的块密码，它基于使用**56位密钥**的对称算法，这个算法因为包含一些机密设计元素，相对短的密钥长度以及被怀疑内含美国国家安全局（NSA）的后门而在开始时是有争议的，DES现在已经不被视为一种安全的加密算法，主要因为它使用的56位密钥过短，导致容易被破解。为了提供实用所需的安全性，可以使用DES的派生算法3DES来进行加密，虽然3DES也存在理论上的攻击方法。\n\n* **AES**：高级加密标准（英语：Advanced Encryption Standard，缩写：AES），这个标准用来替代原先的DES，已经被多方分析且广为全世界所使用，2006年，高级加密标准已然成为对称密钥加密中最流行的算法之一。AES的区块长度固定为128比特，**密钥长度则可以是128，192或256比特**。\n\n* **RC4**：RC4加密算法是大名鼎鼎的RSA三人组中的头号人物Ronald Rivest在1987年设计的密钥长度可变的流加密算法簇。该算法的速度可以达到DES加密的10倍左右，且具有很高级别的非线性。RC4起初是用于保护商业机密的。但是在1994年9月，它的算法被发布在互联网上，也就不再有什么商业机密了。\n\n* **IDEA**：是旅居瑞士中国青年学者来学嘉和著名密码专家J.Massey于1990年提出的。它在1990年正式公布并在以后得到增强。这种算法是在DES算法的基础上发展出来的，类似于三重DES，和DES一样IDEA也是属于对称密钥算法。发展IDEA也是因为感到DES具有密钥太短等缺点，已经过时。**IDEA的密钥为128位**，这么长的密钥在今后若干年内应该是安全的。\n\n### 非对称加密\n\n与对称加密算法不同，非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）；并且加密密钥和解密密钥是成对出现的。非对称加密算法在加密和解密过程使用了不同的密钥，非对称加密也称为公钥加密，在密钥对中，其中一个密钥是对外公开的，所有人都可以获取到，称为公钥，其中一个密钥是不公开的称为私钥。\n\n#### 非对称加密的特性\n\n* 对于一个公钥，有且只有一个对应的私钥。\n* 公钥是公开的，并且不能通过公钥反推出私钥。\n* 通过私钥加密的密文只能通过公钥能解密，通过公钥加密的密文也只能通过私钥能解密。\n\n> 通过公钥是极难推算出私钥的，只能通过穷举，所以只要密钥足够长，要想从公钥推算出私钥几乎不可能的。\n\n#### 非对称加密的主要用途\n\n* **对信息保密，防止中间人攻击**：将明文使用公钥加密，传输给接收者，这样确保信息只能被有私钥的拥有者解密，其他人无法获得明文信息，因为没有私钥无法进行解密。该方法一般用于交换**`对称密钥`**。\n* **身份验证和防止信息篡改**：私钥拥有者使用私钥加密一段授权明文，并将授权明文和加密后的密文，以及公钥一并发送出来，接收方只需要通过公钥将密文解密后与授权明文对比是否一致，就可以判断明文在中途是否被篡改过。此方法用于**`数字签名`**。\n\n#### 常见的非对称加密算法\n\n* **RSA**：1977年，三位数学家Rivest、Shamir 和 Adleman 设计了一种算法，可以实现非对称加密。这种算法用他们三个人的名字命名，叫做RSA算法。从那时直到现在，RSA算法一直是最广为使用的\"非对称加密算法\"。毫不夸张地说，只要有计算机网络的地方，就有RSA算法。这种算法非常可靠，密钥越长，它就越难破解。根据已经披露的文献，目前被破解的最长RSA密钥是768个二进制位。也就是说，长度超过768位的密钥，还无法破解（至少没人公开宣布）。因此可以认为，**1024位的RSA密钥基本安全，2048位的密钥极其安全**。适用于数字签名和密钥交换。 该算法是目前应用最广泛的公钥加密算法，特别适用于通过 Internet 传送的数据。  \n\n* **DSA**：数字签名算法 (Digital Signature Algorithm, DSA) 由美国国家安全署 (United States National Security Agency, NSA) 发明，已作为数字签名的标准。在DSA数字签名和认证中，发送者使用自己的私钥对文件或消息进行签名，接受者收到消息后使用发送者的公钥来验证签名的真实性。DSA只是一种算法，和RSA不同之处在于它不能用作加密和解密，也不能进行密钥交换，只用于签名，它比RSA要快很多。DSA 算法的安全性取决于自计算离散算法的困难。这种算法，不适用于数据加密，仅适用于数字签名。  \n\n* **Diffie-Hellman**：一种确保共享KEY安全穿越不安全网络的方法。Whitefield与Martin Hellman在1976年提出了一个奇妙的密钥交换协议，称为Diffie-Hellman密钥交换协议/算法(Diffie-Hellman Key Exchange/Agreement Algorithm)。这个机制的巧妙在于需要安全通信的双方可以用这个方法确定对称密钥。然后可以用这个密钥进行加密和解密。但是注意，这个密钥交换协议/算法只能用于密钥的交换，而不能进行消息的加密和解密。双方确定要用的密钥后，要使用其他对称密钥操作加密算法实际加密和解密消息。该算法仅适用于密钥交换。\n* **ECC**：椭圆加密算法（ECC）是一种公钥加密体制，最初由Koblitz和Miller两人于1985年提出，与经典的RSA，DSA等公钥密码体制相比，椭圆密码体制有以下优点：160位的椭圆密钥与1024位的RSA密钥安全性相同；在私钥的加密解密速度上，ECC算法比RSA、DSA速度更快；存储空间占用小；带宽要求低；ECC算法的数学理论非常深奥和复杂，在工程应用中比较难于实现，但它的单位安全强度相对较高。\n\n非对称加密算法可能是世界上最重要的算法，它是当今电子商务等领域的基石。非对称加密算法如此强大可靠，却有一个弊端，就是加解密比较耗时。因此，在实际使用中，往往与对称加密和摘要算法结合使用。列如在实体之间交换对称密钥时，或者在签署一封邮件的散列时（数字签名）。\n\n> 散列是通过应用一种单向数学函数获得的一个定长结果，对于数据而言，叫做散列算法。\n\n### 摘要算法\n\n摘要算法是一个神奇的算法，也称为散列或者散列值。是一种与基于密钥（对称密钥或公钥）的加密不同的数据转换类型。散列就是通过把一个叫做散列算法的单向数学函数应用于数据，将任意长度的一块数据转换为一个定长的、不可逆转的数字，其长度通常在128～256位之间。所产生的散列值的长度应足够长，因此使找到两块具有相同散列值的数据的机会很少。\n\n#### 摘要算法具有以下特性：\n\n* 只要源文本不同，计算得到的结果，必然不同（或者说机会很少）。\n* 无法从结果反推出源数据（那是当然的，不然就能量不守恒了）。\n\n#### 常见的摘要算法：\n\n* **MD5**：是RSA数据安全公司开发的一种单向散列算法，MD5被广泛使用，可以用来把不同长度的数据块进行暗码运算成一个固定位位的数值（通常是128位）。\n* **SHA-1**：与 DSA 公钥算法相似，安全散列算法1（SHA-1）也是由 NSA 设计的，并由 NIST 将其收录到 FIPS 中，作为散列数据的标准。它可产生一个 160 位的散列值。SHA-1 是流行的用于创建数字签名的单向散列算法。\n* **MAC（Message Authentication Code）**：消息认证代码，是一种使用密钥的单向函数，可以用它们在系统上或用户之间认证文件或消息，常见的是HMAC（用于消息认证的密钥散列算法）。\n* **CRC（Cyclic Redundancy Check）**：循环冗余校验码，CRC校验由于实现简单，检错能力强，被广泛使用在各种数据校验应用中。占用系统资源少，用软硬件均能实现，是进行数据传输差错检测地一种很好的手段（CRC 并不是严格意义上的散列算法，但它的作用与散列算法大致相同，所以归于此类）。\n\n摘要算法用于对比信息源是否一致，因为只要源数据发生变化，得到的摘要必然不同。因为通常结果比源数据要短很多，所以称为“摘要”。\n\n应用场景，如发件人生成邮件的散列值并加密它，然后将它与邮件本身一起发送。而收件人同时解密邮件和散列值，并由接收到的邮件产生另外一个散列值，然后将两个散列值进行比较。如果两者相同，邮件极有可能在传输期间没有发生任何改变。\n\n### 数字签名\n\n数字签名就是对非对称加密和摘要算法的一种应用，能够确保信息在发布后不会被篡改（摘要算法特性），保证数据的完整性和可信性；同时也可以防止数据被他人伪造（非对称加密算法特性）；列如，我们有一段授权文本需要发布时，为了防止中途篡改发布的内容，保证发布文本的完整性，以及文本是由指定的发布者发布的。那么，可以通过摘要算法得到发布内容的摘要，得到摘要之后，发布者使用私钥加密得到密文（签名），这时候将源文本、密文（签名）以及公钥一起发布出去即可。  \n\n验证过程为：首先验证公钥是否是发布者的公钥，然后用公钥对密文进行解密，得到摘要，使用发布者对文本同样的摘要算法得到摘要文本，比对摘要是否一致即可确认信息是否被篡改或者是指定发布者发布的。\n\n![数字签名](/uploads/数字签名.jpg)\n\n数字签名可以快速验证文本的完整性和合法性，已广泛应用于各个领域。\n\n> 公钥的验证在后续数字证书的授权链中提到验证方法。\n\n### 数字证书\n\n#### 现实生活中的证书\n\n在现实生活中，证书顾名思义，就是权限机构颁发的证明。比如英语6级证书，就是教育部门颁发给通过了6级考核的个人的证明，证明这个人的英语能力。我们来看一下这个证书的组成：\n\n* 被证明人：老王\n* 内容：通过了英语六级\n* 盖章：教育部门的公章或钢印\n\n当老王用这张证书找工作时，用人单位会通过查看证书的各项内容（尤其是公章），来验证证书的合法性和老王的能力。在现实生活中经常有假的6级证书，这些假证书最重要的就是有一个假公章。现实生活中使用法律法规来约束私刻假公章的行为，但是用人单位可能不能十分准确的判断公章是真是假。而数字签字可以来解决该类问题。\n\n#### 数字证书\n\n数字证书就是通过数字签名实现的数字化的证书，在现实生活中公章可以被伪造，但是在计算数字世界中，数字签名是没办法被伪造的，比如上述证书中，在一个证书文件中写明了证书内容，颁发证书时，教育部门用他们的私钥对文件的摘要信息进行签名，将签名和证书文件一起发布，这样就能确保该证书无法被伪造。验证证书是否合法时，首先用教育部门的公钥（公钥是公开的谁都可以获取到）对签名进行解密得到一个摘要信息，使用教育部门同样的摘要算法得到证书的另一个摘要信息，对比两个摘要信息是否一致就能确定该证书是否合法。在一般的证书组成中部分中，还加入了一些其他信息，比如证书的有效期。\n\n数字证书也有很多的签发机构，不同的签发机构签发的证书，用途也是不一样的，比如iOS开发中，使用到的ipa文件签名证书，需要到苹果申请。而在Web访问中为了防止Web内容在网络中安全传输，需要用到的SSL证书则需要向几家公认的机构签发。这些签发机构统称为CA（Certificate Authority）。\n\nWeb访问相关的证书可以向国际公认的几个机构：\n\n1. [**WebTrust**](http://www.webtrust.net/)   \n2. [**GlobalSign**](http://cn.globalsign.com/)  \n3. [**GTE**](http://certificate.fyicenter.com/335_Root_CA_GTE_CyberTrust_Global_Root_GTE_CyberTrust_Solutions.html)\n4. [**Nortel**](http://www.nortel.com/)\n5. [**Verisign**](http://www.verisign.com/)\n\n#### 数字证书的验证\n\n申请证书是为了验证，比如Web应用相关的SSL证书验证方是浏览器，iOS各种证书的验证方是iOS设备。因为数字证书是基于数字签名的，所有数字证书的合法性验证就是验证数字证书的签名是否正确，对于签名的验证在是需要签发机构的公钥才能验证；\n\n对于iOS开发证书来说，申请完签名证书后，还需要安装苹果的公钥证书（XCode安装后会自动安装），这样才能确保我们申请的证书是可以被验证通过的（合法的），可用来进行ipa文件签名的。对于Web相关的证书签名的验证，则是由浏览器来验证，对于国际公认的几个证书签发机构浏览器会内置其公钥证书，用来验证数字证书的可信性。\n\n当数字证书通过验证后，便可以用数字证书做对应的事情，iOS开发证书可以用来对APP进行签名，SSL证书可以用来做Web内容加密处理相关的事情。所以有了这些证书之后，能保证在数据的传输过程中，数据是不会被篡改的，并且信息来源也是不能不修改的，从而确保信息安全。\n\n> 对于iOS，iOS系统已经将这个验证过程固化在系统中了，除非越狱，否则无法绕过\n\n#### 数字证书的授权链\n\n数字证书还包含一个授权链信息，举个例子：如果你要申请休假1周，需要你的上司审批，你的上司需要他的上司同意，最终需要大老板同意，那么这一层层的授权，形成了一个授权链，大老板是授权链的根(root)，中间这些环节分别是被更接近root的人授权的。  \n\n比如苹果开发者的APP签名证书，该证书可以用来对APP进行签名，该证书实际上是由苹果的Worldwide Developer Relations Certificate Authority（WDRCA）授权签名的，而它是由Apple Certificate Authority授权签名的。在这个关系链中苹果的CA是根。 苹果CA根证书默认是内置在苹果系统中的，所以WDRCA的可信性可以由苹果内置的CA根证书来验证其可信性。\n\nWeb相关的SSL证书顶部CA根，则就是上述提到的几家公认的签发机构，当我们需要Web做SSL的证书时，便可以向上述机构申请，通常向根机构申请费用都会比较高，也可以向一些二级授权机构进行申请，选择根机构证书签发的好处就是目前大多数的浏览器都会预装内置了这些权威CA的公钥证书，这样，在使用这些权威CA签发过的证书的时候，浏览器一般不会报风险提示。\n\n#### 总结\n数字证书签名的基础是非对称加密算法，利用了非对称加密的身份验证和防止信息篡改的特性来实现的，在一些其他方面比如HTTPS中密钥交换用的就是非对称加密的保密特性来实现的，在非对称加密算法中RSA应用最广。非对称加密虽好，但却有一个弊端，就是加解密比较耗时，所以一般都是配合对称加密一起使用。\n\n> 本文只是对数字证书做了概要的介绍，很多细节都未涉及到，如果各位对一些细节感兴趣可以根据本文涉及的知识点进入更深入的学习。同时本文也未涉及到数字证书的管理以及数字证书的格式等知识的介绍，这些内容将在后续文章中为大家整理和介绍。\n\n### 参考资料\n[RSA加密与破解](http://www.cnblogs.com/vamei/p/3480994.html)  \n[RSA算法原理](http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html)   \n[漫谈iOS程序的证书和签名机制](http://www.pchou.info/ios/2015/12/14/ios-certification-and-code-sign.html)","slug":"digital-certificate-based","published":1,"updated":"2016-03-17T03:28:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj1a0t08s001dgdp1tm4nftkd","sticky":0},{"title":"两则开发小笔记","date":"2016-07-22T06:22:53.000Z","_content":"\n好久没有写博客了，介绍一下项目中一个 Core Graphics 绘制图片时的效率优化方法，以及记录一下 GCDAsyncSocket 框架在读取网络数据要注意的一个点。\n\n### Core Graphics 绘图性能对比\n\nCore Graphics 框架为我们提供了 2D 绘图能力，在使用 Core Graphics 绘制图片时，不同的实现方法使得渲染图片的效率有很大差异，下面是提供两种不同实现方式的对比，看看 Core Graphics 在绘制图片时效率上的差异。\n\n测试方法为自定义一个 `UIView`，重写`- (void)drawRect:(CGRect)rect` 方法，在该方法中使用 Core Graphics 方式绘制图片。然后在开启一个定时器不断的调用 `- (void)setNeedsDisplay;` 方法来计算绘图所使用的时间。\n<!--more-->\n#### 方法一\n\n```\n- (void)awakeFromNib {\n    self.coreImage = [UIImage imageNamed:@\"IMG_0079.png\"];\n}\n\n- (void)drawRect:(CGRect)rect {\n    struct timeval start , end ;\n    gettimeofday(&start, NULL);\n    [self.coreImage drawAtPoint:CGPointZero];\n    // [self.coreImage drawInRect:CGRectMake(0, 0, 512, 512)];\n    gettimeofday(&end, NULL);\n    long cost = ((end.tv_sec - start.tv_sec) * 1000000 + end.tv_usec - start.tv_usec ) / 1000 ;\n\n    NSLog(@\"cost:%ld\", cost);\n}\n```\n\n#### 方法二\n\n```\n- (void)awakeFromNib {\n    self.coreImage = [UIImage imageNamed:@\"IMG_0079.png\"];\n    CGSize size = self.frame.size;\n    UIGraphicsBeginImageContextWithOptions(size, NO, 0.0);\n    [self.coreImage drawInRect:CGRectMake(0, 0, size.width, size.height)];\n    self.coreImage = UIGraphicsGetImageFromCurrentImageContext();\n    UIGraphicsEndImageContext();\n}\n\n- (void)drawRect:(CGRect)rect {\n    struct timeval start , end ;\n    gettimeofday(&start, NULL);\n    [self.coreImage drawAtPoint:CGPointZero];\n    // [self.coreImage drawInRect:CGRectMake(0, 0, 512, 512)];\n    gettimeofday(&end, NULL);\n    long cost = ((end.tv_sec - start.tv_sec) * 1000000 + end.tv_usec - start.tv_usec ) / 1000 ;\n\n    NSLog(@\"cost:%ld\", cost);\n}\n```\n\n> 使用 `[self.coreImage drawInRect:CGRectMake(0, 0, 512, 512)];` 方法来进行图片的缩放，大小可自定义，只要跟图片本身大小不一致即可。\n\n#### 对比结果\n\n| 方法 | 是否缩放 | 耗时时间 |\n|  :--: | :--: | :--: |\n| 方法一 | NO | 10ms ~ 20ms |\n| 方法一 | YES | 100ms ~ 120ms |\n| 方法二 | NO | 1ms ~ 2ms |\n| 方法二 | YES | 30ms ~ 40ms |\n\n我测试的手机为 iPhone 6 机型，图片为 iPhone 拍摄的照片，上表的中耗时时间跟图片以及机器有关，看对比结果即可；从对比结果可以知道如果在绘制时绘制的大小跟图片本身大小不一致时，系统会对其进行缩放，从而导致绘制效率变低，如果我们提前将图片缩放到指定大小，从而可以提高在绘制时的效率；使用 `UIGraphicsGetImageFromCurrentImageContext` 之前有看到过一篇文章提到，该方法会将图片缓存到显存中，从而使得绘制效率的提高，不过这篇文章已经找不到了。\n\n在实际项目中可选择合适的方法的进行优化，比如图片过大可以使用方法二进行缩放，同时可以放到子线程中进行处理，从而提供绘制时的效率。我在实际项目中的需求为图片可能进行缩放，所以我针对图片做了两级缓存，缩放后在子线程中生成缩放后的图片，同时在缩放的过程中使用了 OpenGL 进行渲染。\n\n### GCDAsyncSocket 读取数据的注意事项\n\n今天一同事使用 GCDAsyncSocket 在测试一个网络程序，发现使用我给的代码，无法接收到数据。代码大概如下：\n\n```\n- (void)push {\n    if (!self.asyncSocket) {\n        self.asyncSocket = [[GCDAsyncSocket alloc] initWithDelegate:self delegateQueue:dispatch_get_main_queue()];\n    }\n    \n    if (!self.bufferData) {\n        self.bufferData = [[NSMutableData alloc] init];\n    }\n    \n    NSError *err = nil;\n    if (![self.asyncSocket connectToHost:PUSH_HOST onPort:PUSH_PORT error:&err]) {\n        NSLog(@\"I goofed: %@\", err);\n        return;\n    }\n}\n\n- (void)socket:(GCDAsyncSocket *)sender didConnectToHost:(NSString *)host port:(UInt16)port {\n    NSString *contentString = @\"data\"\n    NSData *data = [contentString dataUsingEncoding:NSUTF8StringEncoding];\n    [self.asyncSocket writeData:data withTimeout:-1 tag:PUSH_DATA_TAG];\n    [self.asyncSocket readDataToLength:100 withTimeout:-1 buffer:self.bufferData bufferOffset:0 tag:PUSH_DATA_TAG];\n}\n\n- (void)socketDidDisconnect:(GCDAsyncSocket *)sock withError:(NSError *)err {\n    DDLogWarn(@\"SocketDidDisconnect:WithError: %@\", err);\n}\n\n- (void)socket:(GCDAsyncSocket *)sock didReadData:(NSData *)data withTag:(long)tag {\n    DDLogWarn(@\"socket:didReadData: %ld\", tag);\n}\n```\n\n代码流程很简单，客户端在连接上服务器上之后，会给服务器发送一段数据，服务器接收到数据后，在返回一个状态码给到客户端，方法使用上都是正常的；服务器在响应客户端之后，会直接断开连接，上述代码在客户端的实际表现为发送数据到服务器之后，直接就收到断开的回调消息了，并没有接收到服务器响应的数据。\n\n经过测试后发现，`- (void)readDataToLength:(NSUInteger)length withTimeout:(NSTimeInterval)timeout buffer:(NSMutableData *)buffer bufferOffset:(NSUInteger)offset tag:(long)tag;` 一定要接收到指定数据长度后，才会回调对应的方法，而实际服务器返回给到客户端的数据只有两个字节，导致接收数据的方法无法得到回调，就算是连接被断开后也是无法被回调的，导致上层是没办法获取到对应的数据，针对该问题我们可以使用 `- (void)readDataWithTimeout:(NSTimeInterval)timeout buffer:(NSMutableData *)buffer bufferOffset:(NSUInteger)offset tag:(long)tag;` 来解决该问题。\n\n所以在使用 `GCDAsyncSocket` 时得要注意使用合适的方法来获取数据，否则会导致特定情况下无法接收数据回调。","source":"_posts/development-of-small-notes.md","raw":"title: 两则开发小笔记\ndate: 2016-07-22 14:22:53\ncategories: 开发笔记\ntags: [Core Graphics, GCDAsyncSocket]\n---\n\n好久没有写博客了，介绍一下项目中一个 Core Graphics 绘制图片时的效率优化方法，以及记录一下 GCDAsyncSocket 框架在读取网络数据要注意的一个点。\n\n### Core Graphics 绘图性能对比\n\nCore Graphics 框架为我们提供了 2D 绘图能力，在使用 Core Graphics 绘制图片时，不同的实现方法使得渲染图片的效率有很大差异，下面是提供两种不同实现方式的对比，看看 Core Graphics 在绘制图片时效率上的差异。\n\n测试方法为自定义一个 `UIView`，重写`- (void)drawRect:(CGRect)rect` 方法，在该方法中使用 Core Graphics 方式绘制图片。然后在开启一个定时器不断的调用 `- (void)setNeedsDisplay;` 方法来计算绘图所使用的时间。\n<!--more-->\n#### 方法一\n\n```\n- (void)awakeFromNib {\n    self.coreImage = [UIImage imageNamed:@\"IMG_0079.png\"];\n}\n\n- (void)drawRect:(CGRect)rect {\n    struct timeval start , end ;\n    gettimeofday(&start, NULL);\n    [self.coreImage drawAtPoint:CGPointZero];\n    // [self.coreImage drawInRect:CGRectMake(0, 0, 512, 512)];\n    gettimeofday(&end, NULL);\n    long cost = ((end.tv_sec - start.tv_sec) * 1000000 + end.tv_usec - start.tv_usec ) / 1000 ;\n\n    NSLog(@\"cost:%ld\", cost);\n}\n```\n\n#### 方法二\n\n```\n- (void)awakeFromNib {\n    self.coreImage = [UIImage imageNamed:@\"IMG_0079.png\"];\n    CGSize size = self.frame.size;\n    UIGraphicsBeginImageContextWithOptions(size, NO, 0.0);\n    [self.coreImage drawInRect:CGRectMake(0, 0, size.width, size.height)];\n    self.coreImage = UIGraphicsGetImageFromCurrentImageContext();\n    UIGraphicsEndImageContext();\n}\n\n- (void)drawRect:(CGRect)rect {\n    struct timeval start , end ;\n    gettimeofday(&start, NULL);\n    [self.coreImage drawAtPoint:CGPointZero];\n    // [self.coreImage drawInRect:CGRectMake(0, 0, 512, 512)];\n    gettimeofday(&end, NULL);\n    long cost = ((end.tv_sec - start.tv_sec) * 1000000 + end.tv_usec - start.tv_usec ) / 1000 ;\n\n    NSLog(@\"cost:%ld\", cost);\n}\n```\n\n> 使用 `[self.coreImage drawInRect:CGRectMake(0, 0, 512, 512)];` 方法来进行图片的缩放，大小可自定义，只要跟图片本身大小不一致即可。\n\n#### 对比结果\n\n| 方法 | 是否缩放 | 耗时时间 |\n|  :--: | :--: | :--: |\n| 方法一 | NO | 10ms ~ 20ms |\n| 方法一 | YES | 100ms ~ 120ms |\n| 方法二 | NO | 1ms ~ 2ms |\n| 方法二 | YES | 30ms ~ 40ms |\n\n我测试的手机为 iPhone 6 机型，图片为 iPhone 拍摄的照片，上表的中耗时时间跟图片以及机器有关，看对比结果即可；从对比结果可以知道如果在绘制时绘制的大小跟图片本身大小不一致时，系统会对其进行缩放，从而导致绘制效率变低，如果我们提前将图片缩放到指定大小，从而可以提高在绘制时的效率；使用 `UIGraphicsGetImageFromCurrentImageContext` 之前有看到过一篇文章提到，该方法会将图片缓存到显存中，从而使得绘制效率的提高，不过这篇文章已经找不到了。\n\n在实际项目中可选择合适的方法的进行优化，比如图片过大可以使用方法二进行缩放，同时可以放到子线程中进行处理，从而提供绘制时的效率。我在实际项目中的需求为图片可能进行缩放，所以我针对图片做了两级缓存，缩放后在子线程中生成缩放后的图片，同时在缩放的过程中使用了 OpenGL 进行渲染。\n\n### GCDAsyncSocket 读取数据的注意事项\n\n今天一同事使用 GCDAsyncSocket 在测试一个网络程序，发现使用我给的代码，无法接收到数据。代码大概如下：\n\n```\n- (void)push {\n    if (!self.asyncSocket) {\n        self.asyncSocket = [[GCDAsyncSocket alloc] initWithDelegate:self delegateQueue:dispatch_get_main_queue()];\n    }\n    \n    if (!self.bufferData) {\n        self.bufferData = [[NSMutableData alloc] init];\n    }\n    \n    NSError *err = nil;\n    if (![self.asyncSocket connectToHost:PUSH_HOST onPort:PUSH_PORT error:&err]) {\n        NSLog(@\"I goofed: %@\", err);\n        return;\n    }\n}\n\n- (void)socket:(GCDAsyncSocket *)sender didConnectToHost:(NSString *)host port:(UInt16)port {\n    NSString *contentString = @\"data\"\n    NSData *data = [contentString dataUsingEncoding:NSUTF8StringEncoding];\n    [self.asyncSocket writeData:data withTimeout:-1 tag:PUSH_DATA_TAG];\n    [self.asyncSocket readDataToLength:100 withTimeout:-1 buffer:self.bufferData bufferOffset:0 tag:PUSH_DATA_TAG];\n}\n\n- (void)socketDidDisconnect:(GCDAsyncSocket *)sock withError:(NSError *)err {\n    DDLogWarn(@\"SocketDidDisconnect:WithError: %@\", err);\n}\n\n- (void)socket:(GCDAsyncSocket *)sock didReadData:(NSData *)data withTag:(long)tag {\n    DDLogWarn(@\"socket:didReadData: %ld\", tag);\n}\n```\n\n代码流程很简单，客户端在连接上服务器上之后，会给服务器发送一段数据，服务器接收到数据后，在返回一个状态码给到客户端，方法使用上都是正常的；服务器在响应客户端之后，会直接断开连接，上述代码在客户端的实际表现为发送数据到服务器之后，直接就收到断开的回调消息了，并没有接收到服务器响应的数据。\n\n经过测试后发现，`- (void)readDataToLength:(NSUInteger)length withTimeout:(NSTimeInterval)timeout buffer:(NSMutableData *)buffer bufferOffset:(NSUInteger)offset tag:(long)tag;` 一定要接收到指定数据长度后，才会回调对应的方法，而实际服务器返回给到客户端的数据只有两个字节，导致接收数据的方法无法得到回调，就算是连接被断开后也是无法被回调的，导致上层是没办法获取到对应的数据，针对该问题我们可以使用 `- (void)readDataWithTimeout:(NSTimeInterval)timeout buffer:(NSMutableData *)buffer bufferOffset:(NSUInteger)offset tag:(long)tag;` 来解决该问题。\n\n所以在使用 `GCDAsyncSocket` 时得要注意使用合适的方法来获取数据，否则会导致特定情况下无法接收数据回调。","slug":"development-of-small-notes","published":1,"updated":"2016-07-22T06:33:49.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj1a0t08z001ngdp1qjkugox6","sticky":0},{"title":"PKI系统与数字证书结构","date":"2016-04-12T13:24:29.000Z","_content":"\n> 在上一篇[《数字证书的基础知识》](http://www.enkichen.com/2016/02/26/digital-certificate-based/)中介绍了数字证书的一些基础知识以及数字证书的作用，但是并没有提到数字证书的管理，比如数字证书的申请，数字证书的文件格式等知识。这里为大家整理和总结这些相关知识点。\n\nPKI（Public Key Infrastructure）翻译过来就是公钥基础设施，可以理解为利用公钥技术为网络应用提供加密和数字签名等密码服务以及必需的密钥和证书管理体系。它是一个提供安全服务的基础设施，PKI技术是信息安全技术的核心，同时也是电子商务的关键和基础技术。\n\n> PKI既不是一个协议，也不是一个软件，它是一个标准，在这个标准之下发展出的为了实现安全基础服务目的的技术统称为PKI。  \n \n### PKI的组成\n<!--more--> \nPKI是一个标准，它包括一些基本的组件，不同的组件提供不同的服务，主要由一下几个组件组成：\n\n1. **认证中心CA(证书签发)**：CA机构，又称为证书授证 (Certificate Authority) 中心，是PKI的\"核心\"，即数字证书的申请及签发机关，CA必须具备权威性的特征，它负责管理PKI结构下的所有用户(包括各种应用程序)的证书，把用户的公钥和用户的其他信息捆绑在一起，在网上验证用户的身份，CA还要负责用户证书的黑名单登记和黑名单发布。\n2. **X.500目录服务器(证书保存)**：X.500目录服务器用于\"发布\"用户的证书和黑名单信息，用户可通过标准的LDAP协议查询自己或其他人的证书和下载黑名单信息。\n3. **具有高强度密码算法(SSL)的安全WWW服务器(即配置了HTTPS的apache)**：Secure socket layer(SSL)协议最初由Netscape 企业发展，现已成为网络用来鉴别网站和网页浏览者身份，以及在浏览器使用者及网页服务器之间进行加密通讯的全球化标准。\n4. **Web(安全通信平台)**：Web有Web Client端和Web Server端两部分，分别安装在客户端和服务器端，通过具有高强度密码算法的SSL 协议保证客户端和服务器端数据的机密性、完整性、身份验证。\n5. **自开发安全应用系统**：自开发安全应用系统是指各行业自开发的各种具体应用系统，例如银行、证券的应用系统等。\n\n### CA机构\nCA 机构，又称为证书授证 (Certificate Authority) 中心，是一个负责发放和管理数字证书的权威机构 , 它作为电子商务交易中受信任的第三方，承担公钥体系中公钥的合法性检验的责任。 CA 中心为每个使用公开密钥的用户发放一个数字证书，以实现公钥的分发并证明其合法性。数字证书是一个经证书授权中心数字签名的包含公开密钥拥有者信息以及公开密钥的文件 , 作用是证明证书中列出的用户合法拥有证书中列出的公开密钥。 CA 机构的数字签名使得攻击者不能伪造和篡改证书。在 SET 交易中， CA 不仅对持卡人、商户发放证书，还要对获款的银行、网关发放证书。它负责产生、分配并管理所有参与网上交易的个体所需的数字证书，因此是安全电子交易的核心环节。认证中心CA作为PKI的核心部分，CA实现了PKI 中一些很重要的功能：\n\n1. 接收验证最终用户数字证书的申请\n2. 确定是否接受最终用户数字证书的申请-证书的审批\n3. 向申请者颁发、拒绝颁发数字证书-证书的发放\n4. 接收、处理最终用户的数字证书更新请求-证书的更新\n5. 接收最终用户数字证书的查询、撤销\n6. 产生和发布证书废止列表(CRL)\n7. 数字证书的归档\n8. 密钥归档\n9. 历史数据归档\n\n### X.509标准\n\nX.509是一种非常通用的证书格式。所有的证书都符合ITU-T X.509国际标准；因此(理论上)为一种应用创建的证书可以用于任何其他符合X.509标准的应用。在一份证书中，必须证明公钥及其所有者的姓名是一致的。对X.509证书来说，认证者总是 CA或由CA指定的人，一份X.509证书是一些标准字段的集合，这些字段包含有关用户或设备及其相应公钥的信息。X.509标准定义了证书中应该包含哪些信息，并描述了这些信息是如何编码的(即数据格式)，所有的X.509证书包含以下数据。\n\n* **版本号：**指出该证书使用了哪种版本的X.509标准（版本1、版本2或是版本3），版本号会影响证书中的一些特定信息，目前的版本为3\n* **序列号：**  标识证书的唯一整数，由证书颁发者分配的本证书的唯一标识符\n* **签名算法标识符：** 用于签证书的算法标识，由对象标识符加上相关的参数组成，用于说明本证书所用的数字签名算法。例如，SHA-1和RSA的对象标识符就用来说明该数字签名是利用RSA对SHA-1杂凑加密\n* **认证机构的数字签名：**这是使用发布者私钥生成的签名，以确保这个证书在发放之后没有被撰改过\n* **认证机构：** 证书颁发者的可识别名（DN），是签发该证书的实体唯一的CA的X.500名字。使用该证书意味着信任签发证书的实体。(注意：在某些情况下，比如根或顶级CA证书，发布者自己签发证书) \n* **有效期限：** 证书起始日期和时间以及终止日期和时间；指明证书在这两个时间内有效\n* **主题信息：**证书持有人唯一的标识符(或称DN-distinguished name)这个名字在 Internet上应该是唯一的\n* **公钥信息：** 包括证书持有人的公钥、算法(指明密钥属于哪种密码系统)的标识符和其他相关的密钥参数\n* **颁发者唯一标识符：**标识符—证书颁发者的唯一标识符，仅在版本2和版本3中有要求，属于可选项\n\n#### X.509证书扩展部分\n\n可选的标准和专用的扩展（仅在版本2和版本3中使用），扩展部分的元素都有这样的结构：\n\n```\n　　Extension ::= SEQUENCE {\n\n　　extnID OBJECT IDENTIFIER,\n\n　　critical BOOLEAN DEFAULT FALSE,\n\n　　extnValue OCTET STRING }\n\n　　extnID：表示一个扩展元素的OID\n\n　　critical：表示这个扩展元素是否极重要\n\n　　extnValue：表示这个扩展元素的值，字符串类型。\n```\n\n扩展部分包括：\n\n* **发行者密钥标识符：**证书所含密钥的唯一标识符，用来区分同一证书拥有者的多对密钥。\n* **密钥使用：**一个比特串，指明（限定）证书的公钥可以完成的功能或服务，如：证书签名、数据加密等。如果某一证书将 KeyUsage 扩展标记为“极重要”，而且设置为“keyCertSign”，则在 SSL 通信期间该证书出现时将被拒绝，因为该证书扩展表示相关私钥应只用于签写证书，而不应该用于 SSL。\n* **CRL分布点：**指明CRL的分布地点\n* **私钥的使用期：**指明证书中与公钥相联系的私钥的使用期限，它也有Not Before和Not After组成。若此项不存在时，公私钥的使用期是一样的。\n* **证书策略：**由对象标识符和限定符组成，这些对象标识符说明证书的颁发和使用策略有关。\n* **策略映射：**表明两个CA域之间的一个或多个策略对象标识符的等价关系，仅在CA证书里存在\n* **主体别名：**指出证书拥有者的别名，如电子邮件地址、IP地址等，别名是和DN绑定在一起的。\n* **颁发者别名：**指出证书颁发者的别名，如电子邮件地址、IP地址等，但颁发者的DN必须出现在证书的颁发者字段。\n* **主体目录属性：**指出证书拥有者的一系列属性。可以使用这一项来传递访问控制信息。\n\n百度的SSL数字证书：\n\n![百度的SSL数字证书](/uploads/baidudigitalcertificate.png)\n\n#### 数字证书格式\n\n数字证书体现为一个或一系列相关经过加密的数据文件。常见格式有：  \n\n* 符合PKI ITU-T X509标准，传统标准（.DER .PEM .CER .CRT）  \n* 符合PKCS#7 加密消息语法标准(.P7B .P7C .SPC .P7R)  \n* 符合PKCS#10 证书请求标准(.p10)  \n* 符合PKCS#12 个人信息交换标准（.pfx *.p12）  \n\n当然，这只是常用的几种标准，其中，X509证书还分两种编码形式：  \n\n* X.509 DER(Distinguished Encoding Rules)编码，后缀为：.DER .CER .CRT  \n* X.509 BASE64编码，后缀为：.PEM .CER .CRT  \n\nX509是数字证书的基本规范，而P7和P12则是两个实现规范，P7用于数字信封，P12则是带有私钥的证书实现规范。采用的标准不同，生成的数字证书，包含内容也可能不同。下面就证书包含/可能包含的内容做个汇总，一般证书特性有：\n\n* 存储格式：二进制还是ASCII\n* 是否包含公钥、私钥\n* 包含一个还是多个证书\n* 是否支持密码保护（针对当前证书）\n\n其中：\n\n* DER、CER、CRT以二进制形式存放证书，只有公钥，不包含私钥\n* CSR证书请求\n* PEM以Base64编码形式存放证书，以\"-----BEGIN CERTIFICATE-----\" 和 \"-----END CERTIFICATE-----\"封装，只有公钥\n* PFX、P12也是以二进制形式存放证书，包含公钥、私钥，包含保护密码。PFX和P12存储格式完全相同只是扩展名不同\n* P10证书请求\n* P7R是CA对证书请求回复，一般做数字信封\n* P7B/P7C证书链，可包含一个或多个证书\n\n理解关键点：凡是包含私钥的，一律必须添加密码保护（加密私钥），因为按照习惯，公钥是可以公开的，私钥必须保护，所以明码证书以及未加保护的证书都不可能包含私钥，只有公钥，不用加密。  \n\n上文描述中，DER均表示证书且有签名，实际使用中，还有DER编码的私钥不用签名，实际上只是个“中间件”。另外：证书请求一般采用CSR扩展名，但是其格式有可能是PEM也可能是DER格式，但都代表证书请求，只有经过CA签发后才能得到真正的证书。\n\n### 参考资料\n\n[数字证书的基础知识](http://www.enkichen.com/2016/02/26/digital-certificate-based/)  \n[X.509标准](http://www.360doc.com/content/10/0401/23/633992_21238907.shtml)  \n[X.509 数字证书结构简介](http://www.cnblogs.com/watertao/archive/2012/04/08/2437720.html)  \n[数字证书及CA的扫盲介绍](http://kb.cnblogs.com/page/194742/)  \n[openSSL命令、PKI、CA、SSL证书原理](http://www.cnblogs.com/littlehann/p/3738141.html)  ","source":"_posts/certification-and-pki.md","raw":"title: PKI系统与数字证书结构\ndate: 2016-04-12 21:24:29\ncategories: [知识整理/总结]\ntags: [数字证书, PKI]\n---\n\n> 在上一篇[《数字证书的基础知识》](http://www.enkichen.com/2016/02/26/digital-certificate-based/)中介绍了数字证书的一些基础知识以及数字证书的作用，但是并没有提到数字证书的管理，比如数字证书的申请，数字证书的文件格式等知识。这里为大家整理和总结这些相关知识点。\n\nPKI（Public Key Infrastructure）翻译过来就是公钥基础设施，可以理解为利用公钥技术为网络应用提供加密和数字签名等密码服务以及必需的密钥和证书管理体系。它是一个提供安全服务的基础设施，PKI技术是信息安全技术的核心，同时也是电子商务的关键和基础技术。\n\n> PKI既不是一个协议，也不是一个软件，它是一个标准，在这个标准之下发展出的为了实现安全基础服务目的的技术统称为PKI。  \n \n### PKI的组成\n<!--more--> \nPKI是一个标准，它包括一些基本的组件，不同的组件提供不同的服务，主要由一下几个组件组成：\n\n1. **认证中心CA(证书签发)**：CA机构，又称为证书授证 (Certificate Authority) 中心，是PKI的\"核心\"，即数字证书的申请及签发机关，CA必须具备权威性的特征，它负责管理PKI结构下的所有用户(包括各种应用程序)的证书，把用户的公钥和用户的其他信息捆绑在一起，在网上验证用户的身份，CA还要负责用户证书的黑名单登记和黑名单发布。\n2. **X.500目录服务器(证书保存)**：X.500目录服务器用于\"发布\"用户的证书和黑名单信息，用户可通过标准的LDAP协议查询自己或其他人的证书和下载黑名单信息。\n3. **具有高强度密码算法(SSL)的安全WWW服务器(即配置了HTTPS的apache)**：Secure socket layer(SSL)协议最初由Netscape 企业发展，现已成为网络用来鉴别网站和网页浏览者身份，以及在浏览器使用者及网页服务器之间进行加密通讯的全球化标准。\n4. **Web(安全通信平台)**：Web有Web Client端和Web Server端两部分，分别安装在客户端和服务器端，通过具有高强度密码算法的SSL 协议保证客户端和服务器端数据的机密性、完整性、身份验证。\n5. **自开发安全应用系统**：自开发安全应用系统是指各行业自开发的各种具体应用系统，例如银行、证券的应用系统等。\n\n### CA机构\nCA 机构，又称为证书授证 (Certificate Authority) 中心，是一个负责发放和管理数字证书的权威机构 , 它作为电子商务交易中受信任的第三方，承担公钥体系中公钥的合法性检验的责任。 CA 中心为每个使用公开密钥的用户发放一个数字证书，以实现公钥的分发并证明其合法性。数字证书是一个经证书授权中心数字签名的包含公开密钥拥有者信息以及公开密钥的文件 , 作用是证明证书中列出的用户合法拥有证书中列出的公开密钥。 CA 机构的数字签名使得攻击者不能伪造和篡改证书。在 SET 交易中， CA 不仅对持卡人、商户发放证书，还要对获款的银行、网关发放证书。它负责产生、分配并管理所有参与网上交易的个体所需的数字证书，因此是安全电子交易的核心环节。认证中心CA作为PKI的核心部分，CA实现了PKI 中一些很重要的功能：\n\n1. 接收验证最终用户数字证书的申请\n2. 确定是否接受最终用户数字证书的申请-证书的审批\n3. 向申请者颁发、拒绝颁发数字证书-证书的发放\n4. 接收、处理最终用户的数字证书更新请求-证书的更新\n5. 接收最终用户数字证书的查询、撤销\n6. 产生和发布证书废止列表(CRL)\n7. 数字证书的归档\n8. 密钥归档\n9. 历史数据归档\n\n### X.509标准\n\nX.509是一种非常通用的证书格式。所有的证书都符合ITU-T X.509国际标准；因此(理论上)为一种应用创建的证书可以用于任何其他符合X.509标准的应用。在一份证书中，必须证明公钥及其所有者的姓名是一致的。对X.509证书来说，认证者总是 CA或由CA指定的人，一份X.509证书是一些标准字段的集合，这些字段包含有关用户或设备及其相应公钥的信息。X.509标准定义了证书中应该包含哪些信息，并描述了这些信息是如何编码的(即数据格式)，所有的X.509证书包含以下数据。\n\n* **版本号：**指出该证书使用了哪种版本的X.509标准（版本1、版本2或是版本3），版本号会影响证书中的一些特定信息，目前的版本为3\n* **序列号：**  标识证书的唯一整数，由证书颁发者分配的本证书的唯一标识符\n* **签名算法标识符：** 用于签证书的算法标识，由对象标识符加上相关的参数组成，用于说明本证书所用的数字签名算法。例如，SHA-1和RSA的对象标识符就用来说明该数字签名是利用RSA对SHA-1杂凑加密\n* **认证机构的数字签名：**这是使用发布者私钥生成的签名，以确保这个证书在发放之后没有被撰改过\n* **认证机构：** 证书颁发者的可识别名（DN），是签发该证书的实体唯一的CA的X.500名字。使用该证书意味着信任签发证书的实体。(注意：在某些情况下，比如根或顶级CA证书，发布者自己签发证书) \n* **有效期限：** 证书起始日期和时间以及终止日期和时间；指明证书在这两个时间内有效\n* **主题信息：**证书持有人唯一的标识符(或称DN-distinguished name)这个名字在 Internet上应该是唯一的\n* **公钥信息：** 包括证书持有人的公钥、算法(指明密钥属于哪种密码系统)的标识符和其他相关的密钥参数\n* **颁发者唯一标识符：**标识符—证书颁发者的唯一标识符，仅在版本2和版本3中有要求，属于可选项\n\n#### X.509证书扩展部分\n\n可选的标准和专用的扩展（仅在版本2和版本3中使用），扩展部分的元素都有这样的结构：\n\n```\n　　Extension ::= SEQUENCE {\n\n　　extnID OBJECT IDENTIFIER,\n\n　　critical BOOLEAN DEFAULT FALSE,\n\n　　extnValue OCTET STRING }\n\n　　extnID：表示一个扩展元素的OID\n\n　　critical：表示这个扩展元素是否极重要\n\n　　extnValue：表示这个扩展元素的值，字符串类型。\n```\n\n扩展部分包括：\n\n* **发行者密钥标识符：**证书所含密钥的唯一标识符，用来区分同一证书拥有者的多对密钥。\n* **密钥使用：**一个比特串，指明（限定）证书的公钥可以完成的功能或服务，如：证书签名、数据加密等。如果某一证书将 KeyUsage 扩展标记为“极重要”，而且设置为“keyCertSign”，则在 SSL 通信期间该证书出现时将被拒绝，因为该证书扩展表示相关私钥应只用于签写证书，而不应该用于 SSL。\n* **CRL分布点：**指明CRL的分布地点\n* **私钥的使用期：**指明证书中与公钥相联系的私钥的使用期限，它也有Not Before和Not After组成。若此项不存在时，公私钥的使用期是一样的。\n* **证书策略：**由对象标识符和限定符组成，这些对象标识符说明证书的颁发和使用策略有关。\n* **策略映射：**表明两个CA域之间的一个或多个策略对象标识符的等价关系，仅在CA证书里存在\n* **主体别名：**指出证书拥有者的别名，如电子邮件地址、IP地址等，别名是和DN绑定在一起的。\n* **颁发者别名：**指出证书颁发者的别名，如电子邮件地址、IP地址等，但颁发者的DN必须出现在证书的颁发者字段。\n* **主体目录属性：**指出证书拥有者的一系列属性。可以使用这一项来传递访问控制信息。\n\n百度的SSL数字证书：\n\n![百度的SSL数字证书](/uploads/baidudigitalcertificate.png)\n\n#### 数字证书格式\n\n数字证书体现为一个或一系列相关经过加密的数据文件。常见格式有：  \n\n* 符合PKI ITU-T X509标准，传统标准（.DER .PEM .CER .CRT）  \n* 符合PKCS#7 加密消息语法标准(.P7B .P7C .SPC .P7R)  \n* 符合PKCS#10 证书请求标准(.p10)  \n* 符合PKCS#12 个人信息交换标准（.pfx *.p12）  \n\n当然，这只是常用的几种标准，其中，X509证书还分两种编码形式：  \n\n* X.509 DER(Distinguished Encoding Rules)编码，后缀为：.DER .CER .CRT  \n* X.509 BASE64编码，后缀为：.PEM .CER .CRT  \n\nX509是数字证书的基本规范，而P7和P12则是两个实现规范，P7用于数字信封，P12则是带有私钥的证书实现规范。采用的标准不同，生成的数字证书，包含内容也可能不同。下面就证书包含/可能包含的内容做个汇总，一般证书特性有：\n\n* 存储格式：二进制还是ASCII\n* 是否包含公钥、私钥\n* 包含一个还是多个证书\n* 是否支持密码保护（针对当前证书）\n\n其中：\n\n* DER、CER、CRT以二进制形式存放证书，只有公钥，不包含私钥\n* CSR证书请求\n* PEM以Base64编码形式存放证书，以\"-----BEGIN CERTIFICATE-----\" 和 \"-----END CERTIFICATE-----\"封装，只有公钥\n* PFX、P12也是以二进制形式存放证书，包含公钥、私钥，包含保护密码。PFX和P12存储格式完全相同只是扩展名不同\n* P10证书请求\n* P7R是CA对证书请求回复，一般做数字信封\n* P7B/P7C证书链，可包含一个或多个证书\n\n理解关键点：凡是包含私钥的，一律必须添加密码保护（加密私钥），因为按照习惯，公钥是可以公开的，私钥必须保护，所以明码证书以及未加保护的证书都不可能包含私钥，只有公钥，不用加密。  \n\n上文描述中，DER均表示证书且有签名，实际使用中，还有DER编码的私钥不用签名，实际上只是个“中间件”。另外：证书请求一般采用CSR扩展名，但是其格式有可能是PEM也可能是DER格式，但都代表证书请求，只有经过CA签发后才能得到真正的证书。\n\n### 参考资料\n\n[数字证书的基础知识](http://www.enkichen.com/2016/02/26/digital-certificate-based/)  \n[X.509标准](http://www.360doc.com/content/10/0401/23/633992_21238907.shtml)  \n[X.509 数字证书结构简介](http://www.cnblogs.com/watertao/archive/2012/04/08/2437720.html)  \n[数字证书及CA的扫盲介绍](http://kb.cnblogs.com/page/194742/)  \n[openSSL命令、PKI、CA、SSL证书原理](http://www.cnblogs.com/littlehann/p/3738141.html)  ","slug":"certification-and-pki","published":1,"updated":"2016-04-12T13:33:34.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj1a0t093001tgdp1jsam21ek","sticky":0},{"title":"无法旋转的UIWindow子类","date":"2016-01-05T02:36:34.000Z","_content":"\n项目中一直用了两个**UIWindow**，一个是框架默认的，另一个是用来显示调试信息的**UIWindow**。至于为什么要用一个**UIWindow**，而不是用**UIView**呢，是因为**UIView**旋转控制太麻烦了，如果用**UIView**加一个**UIViewController**会方便很多，而且也不用考虑系统版本的区别。  \n<!--more-->\n最近一个同事用同样的方法使用**UIWindow**子类做一个提示框的公用组件，但发现`rootViewController`无法自动旋转。于是我对比了两个**UIWindow**的子类，发现代码并没什么区别，只是多了一些公用方法和一个`delegate`。但就是不能支持旋转，而我的都正常，试过好多方法，都没找到原因。最后只好一部分一部分注释掉一些代码。当我把一个`delegate`的属性注释掉以后，神奇的事情发生了，竟然可以旋转了！！！！ 于是把所有改动都还原了，然后只注释掉`delegate`属性（改一个名称也一样），发现旋转一切正常了。于是在我之前的**UIWindow**子类中添加`delegate`属性，发现也不能进行旋转。  \n\n猜想是不是子类`delegate`属性覆盖了父类的`delegate`属性，而**UIWindow**在控制旋转的逻辑跟`delegate`属性有关。至少有一下两种方式进行调试：  \n\n* 子类**UIWindow**中添加`delegate`属性，然后在setDelegate方法中添加日志。\n* 使用Category为**UIWindow**添加一个`delegate`属性声明，然后打印`delegate`属性\n\n通过上述方法可以发现，**UIWindow**内部实现是存在一个`delegate`属性的，根据日志可以确定该属性是指向`rootViewController`对象。也就是说如果我们在**UIWindow**子类添加`delegate`属性就会影响到**UIWindow**对旋转的控制。  \n\n后续调试发现旋转的相关方法在`rootViewController`中都会正常被调用，但就是没办法进行旋转，也就是说在**UIWindow**子类中添加`delegate`属性和没有添加该属性，对应我们应用来说，该走的方法都会按照正常流程跑完，但就是不能进行旋转。具体原因还未知，后续有新发现将会更新，如果有人知道，还请告知，谢谢，以下我的调试环境：  \n\n> OSX版本为：10.10.5 (14F27)  \n> Xcode 版本为：7.2 (7C68)   \n> SDK：iOS 9.2  \n","source":"_posts/UIWindow-cannot-rotate.md","raw":"title: 无法旋转的UIWindow子类\ndate: 2016-01-05 10:36:34\ncategories: 开发笔记\ntags: [UIWindow, 旋转]\n---\n\n项目中一直用了两个**UIWindow**，一个是框架默认的，另一个是用来显示调试信息的**UIWindow**。至于为什么要用一个**UIWindow**，而不是用**UIView**呢，是因为**UIView**旋转控制太麻烦了，如果用**UIView**加一个**UIViewController**会方便很多，而且也不用考虑系统版本的区别。  \n<!--more-->\n最近一个同事用同样的方法使用**UIWindow**子类做一个提示框的公用组件，但发现`rootViewController`无法自动旋转。于是我对比了两个**UIWindow**的子类，发现代码并没什么区别，只是多了一些公用方法和一个`delegate`。但就是不能支持旋转，而我的都正常，试过好多方法，都没找到原因。最后只好一部分一部分注释掉一些代码。当我把一个`delegate`的属性注释掉以后，神奇的事情发生了，竟然可以旋转了！！！！ 于是把所有改动都还原了，然后只注释掉`delegate`属性（改一个名称也一样），发现旋转一切正常了。于是在我之前的**UIWindow**子类中添加`delegate`属性，发现也不能进行旋转。  \n\n猜想是不是子类`delegate`属性覆盖了父类的`delegate`属性，而**UIWindow**在控制旋转的逻辑跟`delegate`属性有关。至少有一下两种方式进行调试：  \n\n* 子类**UIWindow**中添加`delegate`属性，然后在setDelegate方法中添加日志。\n* 使用Category为**UIWindow**添加一个`delegate`属性声明，然后打印`delegate`属性\n\n通过上述方法可以发现，**UIWindow**内部实现是存在一个`delegate`属性的，根据日志可以确定该属性是指向`rootViewController`对象。也就是说如果我们在**UIWindow**子类添加`delegate`属性就会影响到**UIWindow**对旋转的控制。  \n\n后续调试发现旋转的相关方法在`rootViewController`中都会正常被调用，但就是没办法进行旋转，也就是说在**UIWindow**子类中添加`delegate`属性和没有添加该属性，对应我们应用来说，该走的方法都会按照正常流程跑完，但就是不能进行旋转。具体原因还未知，后续有新发现将会更新，如果有人知道，还请告知，谢谢，以下我的调试环境：  \n\n> OSX版本为：10.10.5 (14F27)  \n> Xcode 版本为：7.2 (7C68)   \n> SDK：iOS 9.2  \n","slug":"UIWindow-cannot-rotate","published":1,"updated":"2016-01-07T02:08:00.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj1a0t096001ygdp11arwz7s9","sticky":0},{"title":"开博第一篇","date":"2015-12-19T01:02:51.000Z","_content":"折腾了几天总算把博客搭建成功了，心情大好，本博客是基于[**GitHub**](https://github.com/)和[**Hexo**](https://hexo.io/)搭建，并使用了[**NexT.Mist**](https://github.com/iissnan/hexo-theme-next)主题，在万网购买的域名，两个域名分别为[**www.enkichen.com**](http://www.enkichen.com)和[**www.enkichen.cn**](http://www.enkichen.cn)，5年400多点大洋，个人觉得还是蛮便宜的。","source":"_posts/First-blog.md","raw":"title: 开博第一篇\ndate: 2015-12-19 09:02:51\ncategories: default\ntags: \n---\n折腾了几天总算把博客搭建成功了，心情大好，本博客是基于[**GitHub**](https://github.com/)和[**Hexo**](https://hexo.io/)搭建，并使用了[**NexT.Mist**](https://github.com/iissnan/hexo-theme-next)主题，在万网购买的域名，两个域名分别为[**www.enkichen.com**](http://www.enkichen.com)和[**www.enkichen.cn**](http://www.enkichen.cn)，5年400多点大洋，个人觉得还是蛮便宜的。","slug":"First-blog","published":1,"updated":"2016-02-29T01:19:02.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj1a0t09a0023gdp1k9oe1zfe","sticky":0}],"PostAsset":[],"PostCategory":[{"post_id":"cj1a0t07y0003gdp1z69trdtu","category_id":"cj1a0t0830004gdp1hsf07goi","_id":"cj1a0t0870007gdp1xqqloyfd"},{"post_id":"cj1a0t089000cgdp1vh2q2nrk","category_id":"cj1a0t08a000dgdp1h7qsfl22","_id":"cj1a0t08b000ggdp1clh3dg1l"},{"post_id":"cj1a0t08c000hgdp13fbkl85m","category_id":"cj1a0t0830004gdp1hsf07goi","_id":"cj1a0t08e000igdp1ujbqx7fh"},{"post_id":"cj1a0t08g000ngdp1nvw45ief","category_id":"cj1a0t08a000dgdp1h7qsfl22","_id":"cj1a0t08h000ogdp1ykzpeljq"},{"post_id":"cj1a0t08k000zgdp1gnx76vkd","category_id":"cj1a0t08a000dgdp1h7qsfl22","_id":"cj1a0t08l0010gdp1n5oht1n1"},{"post_id":"cj1a0t08m0015gdp1974wq7y1","category_id":"cj1a0t0830004gdp1hsf07goi","_id":"cj1a0t08o0016gdp1saldo2b9"},{"post_id":"cj1a0t08p0019gdp12j55z1qb","category_id":"cj1a0t08a000dgdp1h7qsfl22","_id":"cj1a0t08r001agdp151guvqoe"},{"post_id":"cj1a0t08s001dgdp1tm4nftkd","category_id":"cj1a0t08a000dgdp1h7qsfl22","_id":"cj1a0t08t001egdp1c7s8zx00"},{"post_id":"cj1a0t08z001ngdp1qjkugox6","category_id":"cj1a0t0830004gdp1hsf07goi","_id":"cj1a0t090001ogdp1vo32nsm0"},{"post_id":"cj1a0t093001tgdp1jsam21ek","category_id":"cj1a0t08a000dgdp1h7qsfl22","_id":"cj1a0t094001ugdp1qw647so3"},{"post_id":"cj1a0t096001ygdp11arwz7s9","category_id":"cj1a0t0830004gdp1hsf07goi","_id":"cj1a0t098001zgdp12qucwctb"},{"post_id":"cj1a0t09a0023gdp1k9oe1zfe","category_id":"cj1a0t09b0024gdp1bxkk3tqd","_id":"cj1a0t09b0025gdp1hw1qnc89"}],"PostTag":[{"post_id":"cj1a0t07y0003gdp1z69trdtu","tag_id":"cj1a0t0830005gdp1h2xelurm","_id":"cj1a0t0880009gdp1hzf58fbk"},{"post_id":"cj1a0t07y0003gdp1z69trdtu","tag_id":"cj1a0t0870006gdp1n2m3t7or","_id":"cj1a0t088000agdp12sc0igl6"},{"post_id":"cj1a0t07y0003gdp1z69trdtu","tag_id":"cj1a0t0880008gdp1y0j2f3rq","_id":"cj1a0t088000bgdp10ckzu1az"},{"post_id":"cj1a0t089000cgdp1vh2q2nrk","tag_id":"cj1a0t08b000egdp1t9ra9979","_id":"cj1a0t08b000fgdp1p8mlk7aa"},{"post_id":"cj1a0t08c000hgdp13fbkl85m","tag_id":"cj1a0t08e000jgdp1y0266ljr","_id":"cj1a0t08f000lgdp1wf1g16ko"},{"post_id":"cj1a0t08c000hgdp13fbkl85m","tag_id":"cj1a0t08e000kgdp1e4ghb6vn","_id":"cj1a0t08f000mgdp1x37co4v5"},{"post_id":"cj1a0t08g000ngdp1nvw45ief","tag_id":"cj1a0t08h000pgdp1e18iik9g","_id":"cj1a0t08i000ugdp1h4uewipk"},{"post_id":"cj1a0t08g000ngdp1nvw45ief","tag_id":"cj1a0t08h000qgdp13rybtajr","_id":"cj1a0t08j000vgdp1k2v1g8yh"},{"post_id":"cj1a0t08g000ngdp1nvw45ief","tag_id":"cj1a0t08i000rgdp15frdji78","_id":"cj1a0t08j000wgdp1cjdv8edw"},{"post_id":"cj1a0t08g000ngdp1nvw45ief","tag_id":"cj1a0t08i000sgdp1tkp30fhe","_id":"cj1a0t08j000xgdp1o498pmfm"},{"post_id":"cj1a0t08g000ngdp1nvw45ief","tag_id":"cj1a0t08i000tgdp1b7xtocwg","_id":"cj1a0t08j000ygdp13yfvpgwc"},{"post_id":"cj1a0t08k000zgdp1gnx76vkd","tag_id":"cj1a0t08l0011gdp1na7juuur","_id":"cj1a0t08l0013gdp1bo8btxlu"},{"post_id":"cj1a0t08k000zgdp1gnx76vkd","tag_id":"cj1a0t08l0012gdp1e6a4zq6h","_id":"cj1a0t08l0014gdp1iz09x261"},{"post_id":"cj1a0t08m0015gdp1974wq7y1","tag_id":"cj1a0t08o0017gdp1gfdn435t","_id":"cj1a0t08p0018gdp1s8yqipan"},{"post_id":"cj1a0t08p0019gdp12j55z1qb","tag_id":"cj1a0t08r001bgdp17ak79vpe","_id":"cj1a0t08r001cgdp17iuemy0v"},{"post_id":"cj1a0t08s001dgdp1tm4nftkd","tag_id":"cj1a0t08t001fgdp1j1hvghb4","_id":"cj1a0t08w001jgdp1978fdhx5"},{"post_id":"cj1a0t08s001dgdp1tm4nftkd","tag_id":"cj1a0t08u001ggdp13971kndq","_id":"cj1a0t08x001kgdp1bw4epgep"},{"post_id":"cj1a0t08s001dgdp1tm4nftkd","tag_id":"cj1a0t08v001hgdp1mb2qc2ie","_id":"cj1a0t08x001lgdp1moulphej"},{"post_id":"cj1a0t08s001dgdp1tm4nftkd","tag_id":"cj1a0t08w001igdp1ub6a4wkb","_id":"cj1a0t08x001mgdp1n2fcz9kr"},{"post_id":"cj1a0t08z001ngdp1qjkugox6","tag_id":"cj1a0t090001pgdp1pcsq9fts","_id":"cj1a0t091001rgdp1bqc1eytt"},{"post_id":"cj1a0t08z001ngdp1qjkugox6","tag_id":"cj1a0t091001qgdp1yq3kf19d","_id":"cj1a0t091001sgdp1euw4wj2p"},{"post_id":"cj1a0t093001tgdp1jsam21ek","tag_id":"cj1a0t08t001fgdp1j1hvghb4","_id":"cj1a0t095001wgdp1h9rtrjlp"},{"post_id":"cj1a0t093001tgdp1jsam21ek","tag_id":"cj1a0t095001vgdp1k4yzzcg4","_id":"cj1a0t095001xgdp1qh66j49t"},{"post_id":"cj1a0t096001ygdp11arwz7s9","tag_id":"cj1a0t0980020gdp13qmxbvv2","_id":"cj1a0t0990021gdp16uzrclqg"},{"post_id":"cj1a0t096001ygdp11arwz7s9","tag_id":"cj1a0t0880008gdp1y0j2f3rq","_id":"cj1a0t0990022gdp1vgorjcvb"}],"Tag":[{"name":"SDWebImage","_id":"cj1a0t0830005gdp1h2xelurm"},{"name":"NSCache","_id":"cj1a0t0870006gdp1n2m3t7or"},{"name":"旋转","_id":"cj1a0t0880008gdp1y0j2f3rq"},{"name":"Protobuf","_id":"cj1a0t08b000egdp1t9ra9979"},{"name":"OpenGL","_id":"cj1a0t08e000jgdp1y0266ljr"},{"name":"纹理","_id":"cj1a0t08e000kgdp1e4ghb6vn"},{"name":"开发证书","_id":"cj1a0t08h000pgdp1e18iik9g"},{"name":"代码签名","_id":"cj1a0t08h000qgdp13rybtajr"},{"name":"mobileprovision","_id":"cj1a0t08i000rgdp15frdji78"},{"name":"Provisioning Profiles","_id":"cj1a0t08i000sgdp1tkp30fhe"},{"name":"开发者账号","_id":"cj1a0t08i000tgdp1b7xtocwg"},{"name":"associative","_id":"cj1a0t08l0011gdp1na7juuur"},{"name":"runtime","_id":"cj1a0t08l0012gdp1e6a4zq6h"},{"name":"HTTP","_id":"cj1a0t08o0017gdp1gfdn435t"},{"name":"Git","_id":"cj1a0t08r001bgdp17ak79vpe"},{"name":"数字证书","_id":"cj1a0t08t001fgdp1j1hvghb4"},{"name":"非对称加密","_id":"cj1a0t08u001ggdp13971kndq"},{"name":"RSA","_id":"cj1a0t08v001hgdp1mb2qc2ie"},{"name":"摘要算法","_id":"cj1a0t08w001igdp1ub6a4wkb"},{"name":"Core Graphics","_id":"cj1a0t090001pgdp1pcsq9fts"},{"name":"GCDAsyncSocket","_id":"cj1a0t091001qgdp1yq3kf19d"},{"name":"PKI","_id":"cj1a0t095001vgdp1k4yzzcg4"},{"name":"UIWindow","_id":"cj1a0t0980020gdp13qmxbvv2"}]}}